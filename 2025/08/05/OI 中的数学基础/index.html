

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="stripe-python">
  <meta name="keywords" content="">
  
    <meta name="description" content="为什么要写这篇文章呢？因为教练让我们选一个专题写博客然后交流。 为什么选数学呢？因为线段树分块都被选走了，而数学专题没人选，并且可以把写过的笔记拼起来（ 本文章涉及数论 &amp; 组合数学两个部分，还包含一些数学杂项，整体内容比较简单。 本文代码中出现的 modint 或 mint 是笔者编写的自动取模工具，代码可见 this。 质数定义一个正整数 $p$ 为质数，即它不存在 $1$ 和 $p$">
<meta property="og:type" content="article">
<meta property="og:title" content="Stripe-Python&#39;s Blog">
<meta property="og:url" content="http://example.com/2025/08/05/OI%20%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Stripe-Python&#39;s Blog">
<meta property="og:description" content="为什么要写这篇文章呢？因为教练让我们选一个专题写博客然后交流。 为什么选数学呢？因为线段树分块都被选走了，而数学专题没人选，并且可以把写过的笔记拼起来（ 本文章涉及数论 &amp; 组合数学两个部分，还包含一些数学杂项，整体内容比较简单。 本文代码中出现的 modint 或 mint 是笔者编写的自动取模工具，代码可见 this。 质数定义一个正整数 $p$ 为质数，即它不存在 $1$ 和 $p$">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xsvja4az.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/y4q3udx2.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/0ztrlo61.png">
<meta property="og:image" content="https://i.loli.net/2020/02/02/2xksBinHCIXUWrg.png">
<meta property="og:image" content="https://i.loli.net/2020/02/02/RJmZdy1kc5qTEbF.png">
<meta property="og:image" content="https://i.loli.net/2020/02/02/KXQ4GyxiBv1cOwz.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/x5tfyila.png">
<meta property="og:image" content="https://oi-wiki.org/string/images/trie1.png">
<meta property="article:published_time" content="2025-08-05T07:14:58.094Z">
<meta property="article:modified_time" content="2025-08-05T07:14:35.398Z">
<meta property="article:author" content="stripe-python">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xsvja4az.png">
  
  
  
  <title>Stripe-Python&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-05 15:14" pubdate>
          2025年8月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          300 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <p>为什么要写这篇文章呢？因为教练让我们选一个专题写博客然后交流。</p>
<p>为什么选数学呢？因为线段树分块都被选走了，而数学专题没人选，并且可以把写过的笔记拼起来（</p>
<p>本文章涉及数论 &amp; 组合数学两个部分，还包含一些数学杂项，整体内容比较简单。</p>
<p>本文代码中出现的 <code>modint</code> 或 <code>mint</code> 是笔者编写的自动取模工具，代码可见 <a target="_blank" rel="noopener" href="https://www.luogu.me/paste/6wwixwot">this</a>。</p>
<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>定义一个正整数 $p$ 为质数，即它不存在 $1$ 和 $p$ 以外的约数。$1$ 不是质数。</p>
<h2 id="质数的判定"><a href="#质数的判定" class="headerlink" title="质数的判定"></a>质数的判定</h2><h3 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h3><p>可以枚举 $[1,\sqrt{n}]$ 中的整数，判定其是否为 $p$ 的约数。因为 $a \mid p$ 时 $\dfrac{p}{a}\mid p$，所以无需枚举到 $n$。复杂度为 $O(\sqrt{n})$。</p>
<p>这里给出一个 $\dfrac{1}{6}$ 常数的实现，筛掉 $2$ 和 $3$ 的倍数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">if</span> (x == <span class="hljs-number">2</span> || x == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">if</span> (x % <span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; x % <span class="hljs-number">6</span> != <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i * i &lt;= x; i += <span class="hljs-number">6</span>) &#123;<br>		<span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span> || x % (i + <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Miller-Rabin-法"><a href="#Miller-Rabin-法" class="headerlink" title="Miller-Rabin 法"></a>Miller-Rabin 法</h3><p>先引入二次探测定理，即：若 $p$ 为奇质数，则 $x^2 \equiv 1 \pmod p$ 的解为 $x \equiv 1$ 或 $x \equiv p-1$。</p>
<blockquote>
<p>简证：由 $x^2 \equiv 1 \pmod p$ 得 $(x-1)(x+1) \equiv 0 \pmod p$，即可得出。</p>
</blockquote>
<p>接下来使用费马小定理：若 $p$ 为质数且 $\gcd(a,p)&#x3D;1$，则 $a^{p-1} \equiv 1 \pmod p$。这个结论的讲解可到文章下部。</p>
<p>设 $p-1&#x3D;u \times 2^t$，随机一个 $a$ 值并求得 $v&#x3D;a^u \bmod p$，然后执行 $t$ 次 $v \gets v^2 \bmod p$，检查是否满足 $a^{p-1} \equiv 1 \pmod p$。</p>
<p>在 long long 范围内，只需选取 $a \in {2,325,9375,28178,450775,9780504,1795265022}$ 即可保证正确性。复杂度 $O(\log n)$。这里给出一个比较科技的写法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (a %= p; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = (__int128) res * a % p;<br>		a = (__int128) a * a % p;<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> BASE[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">325</span>, <span class="hljs-number">9375</span>, <span class="hljs-number">28178</span>, <span class="hljs-number">450775</span>, <span class="hljs-number">9780504</span>, <span class="hljs-number">1795265022</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">miller_rabin</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span> || n % <span class="hljs-number">6</span> % <span class="hljs-number">4</span> != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (n | <span class="hljs-number">1</span>) == <span class="hljs-number">3</span>;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> s = __builtin_ctzll(n - <span class="hljs-number">1</span>), d = n &gt;&gt; s;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> a : BASE) &#123;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> p = <span class="hljs-built_in">power</span>(a, d, n), i = s;<br>		<span class="hljs-keyword">while</span> (p != <span class="hljs-number">1</span> &amp;&amp; p != n - <span class="hljs-number">1</span> &amp;&amp; a % n &amp;&amp; i--) p = (__int128) p * p % n;<br>		<span class="hljs-keyword">if</span> (p != n - <span class="hljs-number">1</span> &amp;&amp; i != s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>若 $p$ 为质数，则<br>$$<br>(p-1)! \equiv -1 \pmod p<br>$$<br>其逆定理也成立。即若 $(p-1)! \equiv -1 \pmod p$，则 $p$ 为质数。</p>
<h2 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h2><p>任何一个合数 $n$ 可以唯一分解成有限个质数的乘积。</p>
<p>存在性：用反证法，假设 $n$ 是最小的不能被分解的合数，则存在 $n&#x3D;ab$，若 $a,b$ 都可分解，则 $n$ 可以被分解；若 $a,b$ 有不可分解的数，则 $a,b$ 才是最小的数，矛盾。</p>
<p>唯一性：用反证法，假设 $n$ 是最小的存在两种分解的合数，如果 $n$ 存在两种分解 $n&#x3D;{p_1}^{a_1} {p_2}^{a_2} \cdots &#x3D;{q_1}^{b_1} {q_2}^{b_2} \cdots$，则 $p_1 | {q_1}^{b_1} {q_2}^{b_2} \cdots$，也就是 ${q_1}^{b_1} {q_2}^{b_2} \cdots$ 中有一个 ${q_i}{b_i}$ 可以整除 $p_1$，故 $p_1&#x3D;q_i$，同除 $p_1$，则 ${p_2}^{a_2} \cdots $ 也是存在两种分解的合数，矛盾。</p>
<h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><p>设 $n$ 可以质因数分解为 $n&#x3D;p_1^{c_1} p_2^{c_2} p_3^{c_3} \cdots p_m^{c_m}$。</p>
<p>推论 1：$n$ 的正约数个数为</p>
<p>$$<br>(c_1+1)(c_2+1)(c_3+1)\cdots(c_m+1)&#x3D;\prod_{i&#x3D;1}^{m} (c_i+1)<br>$$</p>
<p>推论 2：$n$ 的所有正约数和为</p>
<p>$$<br>(1+p_1+p_1^2+\cdots+p_1^{c_1})\cdots(1+p_m+p_m^2+\cdots+p_m^{c_m})&#x3D;\prod_{i&#x3D;1}^{m} [\sum_{j&#x3D;0}^{c_i} {p_i}^j]<br>$$</p>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><h4 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h4><p>与枚举法判素数同种原理，复杂度 $O(\sqrt{n})$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], c[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">decompose</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>		p[++m] = i, c[m] = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i, c[m]++;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) p[++m] = n, c[m] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，如果知道 $n$ 的值域，可以先用下面的质数筛打出一个质数表。由于质数平均隔 $O(\log n)$ 次出现一次，这样就省去了 $O(\log n)$ 次试除，故单次试除的复杂度降为 $O(\dfrac{\sqrt{n}}{\log n})$。</p>
<h2 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><p>小学课本上学过，我们每遍历到一个质数，就把它的倍数划去，最后剩下的未被划去的就是质数。埃氏筛使用 bitset 优化后速度快于线性筛。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bitset&lt;N&gt; isprime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>	isprime.<span class="hljs-built_in">set</span>(), isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= N; i++) &#123;  <span class="hljs-comment">// 一个常数优化：筛到 O(sqrt(N)) 即可</span><br>		<span class="hljs-keyword">if</span> (!isprime[i]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1LL</span> * i * i; j &lt; N; j += i) isprime[j] = <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>复杂度为 $O(n \log \log n)$。但是在实际计算中，bitset 优化后，它比 $O(n)$ 的线性筛更优秀。</p>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>线性筛虽然跑不过 bitset 埃氏筛，但是它的思想值得学习。</p>
<p>埃氏筛复杂度到不了线性的原因是它会把一个合数划掉两遍。具体地，在标记 $i \times prime_j$ 时，需要确保 $i$ 的最小质因子不小于 $p$，即 $i\bmod prime_j &#x3D;0$ 时跳出循环，这样复杂度就降到了 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bitset&lt;N&gt; isprime;<br><span class="hljs-type">int</span> tot, prime[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>	isprime.<span class="hljs-built_in">set</span>(), isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">if</span> (isprime[i]) prime[++tot] = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot; j++) &#123;<br>			<span class="hljs-keyword">if</span> (i * prime[j] &gt;= N) <span class="hljs-keyword">break</span>;<br>			isprime[i * prime[j]] = <span class="hljs-literal">false</span>;<br>			<span class="hljs-keyword">if</span> (i &amp; prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="区间筛"><a href="#区间筛" class="headerlink" title="区间筛"></a>区间筛</h3><p>在一些题目中，我们可能需要求出 $[l,r]$ 中的质数，其中 $l,r \le 10^{14}$ 但 $r-l \le 10^7$。区间筛可在 $O(n \log \log n)$ 的时间复杂度内解决问题，其中 $n&#x3D;\max(\sqrt{r},r-l)$。</p>
<p>观察到 $[l,r]$ 中的合数的最大质因数不会超过 $\sqrt{r}$，这意味着我们可以用埃氏筛先处理出 $[1,\sqrt{r}]$ 内的质数，再用这些质数去筛掉 $[l,r]$ 中的合数。这也就是埃氏筛那个常数优化的原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bitset&lt;N&gt; s, p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <span class="hljs-comment">// 筛出[a, b)之间的质数，用 p[i - a] 判断i是否为质数</span><br>	s.<span class="hljs-built_in">set</span>(), p.<span class="hljs-built_in">set</span>(), s[<span class="hljs-number">0</span>] = s[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">if</span> (a &lt;= <span class="hljs-number">1</span>) p[<span class="hljs-number">1</span> - a] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-type">int</span> z = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sqrt</span>(b) + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; z; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; i * j &lt; z; j++) s[i * j] = <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= b; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!s[i]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">max</span>(i * i, (a + i - <span class="hljs-number">1</span>) / i * i); j &lt; b; j += i) p[j - a] = <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1147-连续自然数和"><a href="#P1147-连续自然数和" class="headerlink" title="P1147 连续自然数和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1147">P1147 连续自然数和</a></h3><p>这种题型是一类常见题型，给出 $n$，并对于所求 $a,b$ 有 $ab&#x3D;n$，则可以枚举 $n$ 的因数求解。</p>
<p>由等差数列求和：<br>$$<br>\dfrac{(l+r)(r-l+1)}{2}&#x3D;n<br>$$</p>
<p>枚举 $2n&#x3D;ij$，则 </p>
<p>$$<br>\left{\begin{matrix}<br>r-l+1&#x3D;i\<br>l+r&#x3D;j \<br>\end{matrix}\right.<br>$$</p>
<p>解得</p>
<p>$$<br>\left{\begin{matrix}<br>l&#x3D;\dfrac{j-i+1}{2} \<br>r&#x3D;\dfrac{j+i-1}{2}<br>\end{matrix}\right.<br>$$</p>
<p>显然，$i,j$ 奇偶性应不同，且 $i$ 倒序枚举。复杂度 $O(\sqrt{n})$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n; n *= <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">sqrt</span>(n); i &gt;= <span class="hljs-number">2</span>; i--) &#123;<br>		<span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-type">int</span> j = n / i;<br>		<span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) + (j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cout &lt;&lt; (j - i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; (j + i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="P1865-A-B-Problem"><a href="#P1865-A-B-Problem" class="headerlink" title="P1865 A % B Problem"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1865">P1865 A % B Problem</a></h3><p>由 $m \le 10^6$ 可以筛一下 $m$ 以内的质数，询问用前缀和处理。远古代码太丑了不想放。</p>
<h3 id="P7960-NOIP2021-报数"><a href="#P7960-NOIP2021-报数" class="headerlink" title="P7960 [NOIP2021] 报数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7960">P7960 [NOIP2021] 报数</a></h3><p>质数筛的思想延伸。把含有 $7$ 的数先暴力找见，然后把它的倍数筛掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 注意这里要开大点</span><br><span class="hljs-type">int</span> t, x, nxt[N];<br>bitset&lt;N&gt; dis;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (; x != <span class="hljs-number">0</span>; x /= <span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> (x % <span class="hljs-number">10</span> == <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	<span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>	dis.<span class="hljs-built_in">reset</span>();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">if</span> (dis[i]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i)) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * i &lt; N; j++) dis[j * i] = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		nxt[last] = i, last = i;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (cin &gt;&gt; t; t--; ) &#123;<br>		cin &gt;&gt; x;<br>		cout &lt;&lt; (dis[x] ? <span class="hljs-number">-1</span> : nxt[x]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P1069-NOIP-2009-普及组-细胞分裂"><a href="#P1069-NOIP-2009-普及组-细胞分裂" class="headerlink" title="P1069 [NOIP 2009 普及组] 细胞分裂"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1069">P1069 [NOIP 2009 普及组] 细胞分裂</a></h3><p>形式化题意：给出 $m&#x3D;{m_1}^{m_2}$ 和 $n$ 个正整数 $a_i$，求</p>
<p>$$<br>\min_{i \in [1,n]} \min_{m\mid a_i^k} k<br>$$</p>
<p>显然这题 $m$ 不能给它算出来，对 $m_1$ 分解质因数，则</p>
<p>$$<br>m&#x3D;{m_1}^{m_2}&#x3D;(p_1^{c_1} p_2^{c_2} p_3^{c_3} \cdots p_h^{c_h})^{m_2}&#x3D;p_1^{c_1m_2} p_2^{c_2m_2} p_3^{c_3m_2} \cdots p_h^{c_hm_2}<br>$$</p>
<p>这样就得到了 $m$ 的质因数分解。对于每个 $a_i$，当且仅当 $\forall p_j, p_j \mid  a_i$ 时有解，否则 $a_i$ 自乘多少次都不能使 $m$ 成为其约数。</p>
<p>接下来我们求出 $p_j$ 在 $a_i$ 中出现的次数 $cnt$。则对于 $p_j$ 而言，$\min k&#x3D;\lceil \dfrac{c_j}{cnt} \rceil$。然后用木桶原理，对所有 $\min k$ 取 $\max$，为 $a_i$ 的答案。总复杂度 $O(n \sqrt{V})$，$V$ 是值域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m1, m2, a[N], tot;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) &#123;<br>		<span class="hljs-keyword">if</span> (x % p[i]) <span class="hljs-keyword">return</span> INT_MAX;<br>		<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (x % p[i] == <span class="hljs-number">0</span>) x /= p[i], cnt++;<br>		res = <span class="hljs-built_in">max</span>(res, c[i] / cnt + (c[i] % cnt != <span class="hljs-number">0</span>));<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	tot = <span class="hljs-built_in">decompose</span>(m1);  <span class="hljs-comment">// 这个函数文章前面有</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) c[i] *= m2;<br>	<span class="hljs-type">int</span> res = INT_MAX;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">solve</span>(a[i]));<br>	cout &lt;&lt; (res == INT_MAX ? <span class="hljs-number">-1</span> : res);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AT-abc412-e-ABC412E-LCM-Sequence"><a href="#AT-abc412-e-ABC412E-LCM-Sequence" class="headerlink" title="AT_abc412_e [ABC412E] LCM Sequence"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc412_e">AT_abc412_e [ABC412E] LCM Sequence</a></h3><p>打个表可以发现，$A_n$ 发生变化当且仅当 $n$ 为质数或质数的幂。稍后证明此结论。然后我们用区间筛把质数筛出来，并且在筛法过程中处理质数的幂即可。注意 $A_l$ 贡献是单独的。还有一种方法是用 Miller-Rabin 判质数并且处理质数幂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> l, r;<br>bitset&lt;N&gt; s, p;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	s.<span class="hljs-built_in">set</span>(), p.<span class="hljs-built_in">set</span>();<br>	<span class="hljs-type">int</span> z = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sqrt</span>(b) + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; z; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; i * j &lt; z; j++) s[i * j] = <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= b; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!s[i]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">max</span>(i * i, (a + i - <span class="hljs-number">1</span>) / i * i); j &lt; b; j += i) p[j - a] = <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= b; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!s[i]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-type">int</span> j = i * i;<br>		<span class="hljs-keyword">while</span> (j &lt; a) j *= i;<br>		<span class="hljs-keyword">for</span> (; j &lt; b; j *= i) p[j - a] = <span class="hljs-literal">true</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; l &gt;&gt; r;<br>	<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">solve</span>(l, r + <span class="hljs-number">1</span>);<br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) cnt += p[i - l];<br>	<span class="hljs-keyword">if</span> (!p[<span class="hljs-number">0</span>]) cnt++;<br>	cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面证明上述结论。由算术基本定理可设 $n&#x3D;{p_1}^{q_1}{p_2}^{q_2} \cdots {p_m}^{q_m}$。若 $m&gt;1$，只要存在 $^{q_i}$ 的倍数，$n$ 加入就不会改变 $\operatorname{lcm}$。而若 $m&#x3D;1$，此时 $n&#x3D;{p_1}^{q_1}&gt;n-1$，此时 $n$ 为质数幂。</p>
<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="求解-GCD"><a href="#求解-GCD" class="headerlink" title="求解 GCD"></a>求解 GCD</h2><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>C++ STL 中有函数 <code>std::__gcd</code>，为迭代的辗转相除法实现，复杂度为 $O(\log n)$，可以直接使用。</p>
<h3 id="分解质因数法"><a href="#分解质因数法" class="headerlink" title="分解质因数法"></a>分解质因数法</h3><p>将两数分解质因数：$a&#x3D;p_1^{a_1}p_2^{a_2} \cdots, b&#x3D;a&#x3D;p_1^{b_1}p_2^{b_2} \cdots$，则 $\gcd(a,b)&#x3D;p_1^{\min(a_1,b_1)}p_2^{\min(a_2,b_2)} \cdots$，复杂度为 $O(\sqrt{n})$。</p>
<p>这证明：求 gcd 和求最小值有共通之处。</p>
<h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>GCD 有如下性质：</p>
<p>$$<br>\gcd(a,b)&#x3D;\gcd(b,a \bmod b)<br>$$</p>
<p>利用此可递归计算 gcd，出口为 $\gcd(a,0)&#x3D;a$。复杂度 $O(\log (a+b))$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);&#125;<br></code></pre></td></tr></table></figure>

<h3 id="更相减损法"><a href="#更相减损法" class="headerlink" title="更相减损法"></a>更相减损法</h3><p>GCD 有如下性质：</p>
<p>$$<br>\gcd(a,b)&#x3D;\gcd(a-b,b)<br>$$</p>
<p>如果直接递归计算，复杂度为 $O(n)$。Stein 算法对此进行了优化：</p>
<p>若 $2\mid a$ 且 $2\mid b$，则 $\gcd(a,b)&#x3D;2\gcd(\dfrac{a}{2},\dfrac{b}{2})$。而若只有 $2 \mid  a$，则 $\gcd(a,b)&#x3D;\gcd(\dfrac{a}{2},b)$。这启示我们可以在过程中除掉约数 $2$，复杂度降到了 $O(\log n)$。Stein 算法常用于大整数的 GCD。</p>
<p>Stein 算法可以借助二进制内置函数优化，称作 Binary GCD，理论复杂度 $O(\log (a+b))$，但在实际表现中可以看作大常数 $O(1)$。这份代码的速度比 <code>std::__gcd</code> 更快，可以卡过 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5435">P5435</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	<span class="hljs-type">int</span> az = __builtin_ctz(a), bz = __builtin_ctz(b), z = <span class="hljs-built_in">min</span>(az, bz);<br>	b &gt;&gt;= bz;<br>	<span class="hljs-keyword">while</span> (a) &#123;<br>		a &gt;&gt;= az;<br>		<span class="hljs-type">int</span> d = a - b;<br>		az = __builtin_ctz(d);<br>		b = <span class="hljs-built_in">min</span>(a, b), a = <span class="hljs-built_in">abs</span>(d);<br>	&#125;<br>	<span class="hljs-keyword">return</span> b &lt;&lt; z;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="exGCD"><a href="#exGCD" class="headerlink" title="exGCD"></a>exGCD</h2><p>exGCD 用于求解形如 $ax+by&#x3D;\gcd(a,b)$ 一类的不定方程。</p>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>对于任意非零整数 $a,b$，$ax+by&#x3D;c$ 有整数解当且仅当 $c \mid  \gcd(a,b)$。</p>
<h4 id="推论-1"><a href="#推论-1" class="headerlink" title="推论"></a>推论</h4><p>若 $a_1,a_2,a_3,\cdots,a_n$ 是不全为 $0$ 的整数，则存在整数 $x_1,x_2,x_3,\cdots,x_n$ 使得<br>$$<br>a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n&#x3D;\gcd(a_1,a_2,a_3,\cdots,a_n)<br>$$<br>其逆定理也成立。</p>
<h3 id="不定方程"><a href="#不定方程" class="headerlink" title="不定方程"></a>不定方程</h3><p>由 $\gcd(a,b)&#x3D;\gcd(b,a\bmod b)$ 得：</p>
<p>$$<br>\begin{aligned}<br>ax+by&amp;&#x3D;bx’+(a\bmod b)y’\<br>&amp;&#x3D;bx’+(a-b\lfloor \dfrac{a}{b} \rfloor)y’\<br>&amp;&#x3D;ay’+b(x’-y’\lfloor \dfrac{a}{b} \rfloor)<br>\end{aligned}<br>$$</p>
<p>递归式：$x&#x3D;y’,y&#x3D;x’-y’\lfloor \dfrac{a}{b} \rfloor$，这样就可以 $O(\log (a+b))$ 求解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>逆元就是模意义下的倒数：求 $x \equiv \dfrac{1}{a} \pmod m$ 的解。</p>
<p>移项得：$ax \equiv 1 \pmod m$，即为求解不定方程 $ax-bm&#x3D;1$，用 exGCD 求解即可。</p>
<p>这里可以发现，$x$ 在模 $m$ 意义下有逆元当且仅当 $x,m$ 互质。利用乘法逆元，可以实现模意义下的除法。</p>
<h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><p>这里的线性方程组是指求一个最小的 $x$ 满足<br>$$<br>\left{\begin{matrix}<br>x \equiv a_1 \pmod {m_1} \<br>x \equiv a_2 \pmod {m_2} \<br>\cdots \<br>x \equiv a_n \pmod {m_n}<br>\end{matrix}\right.<br>$$<br>两两考虑。比如我们把前两个方程变成不定方程：$x&#x3D;m_1p+a_1&#x3D;m_2q+a_2$。则 $m_1p-m_2q&#x3D;a_2-a_1$，利用 exGCD 解出一组可行解 $(p,q)$，然后这两个方程组的共同解为 $x \equiv (m_1p+a_1) \pmod {\operatorname{lcm}(m_1,m_2)}$。然后把 $n$ 个方程都这么合并起来即可。</p>
<p>至于为什么不说 CRT，因为我觉得 exCRT 比 CRT 更容易理解，适用范围更广，代码还好写。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="P1072-NOIP-2009-提高组-Hankson-的趣味题"><a href="#P1072-NOIP-2009-提高组-Hankson-的趣味题" class="headerlink" title="P1072 [NOIP 2009 提高组] Hankson 的趣味题"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1072">P1072 [NOIP 2009 提高组] Hankson 的趣味题</a></h3><p>有一个结论：若 $\gcd(a,b)&#x3D;c$，且 $a&#x3D;k_1c,b&#x3D;k_2c$，则 $\gcd(k_1,k_2)&#x3D;1$。</p>
<p>证明：考虑反证法，设 $K&#x3D;\gcd(k_1,k_2) \ne 1$，则存在不为 $1$ 的正整数 $p,q$ 使得 $k_1&#x3D;pK,k_2&#x3D;qK$，因而 $a&#x3D;pKc,b&#x3D;qKc$，$\gcd(a,b)&#x3D;Kc \ne c$，故原结论成立。</p>
<p>由题可得：$x&#x3D;a_1 p$，$b_1&#x3D;xq$，其中 $p,q$ 为正整数。</p>
<p>由上述结论得：$\gcd(\dfrac{a_0}{a_1},\dfrac{x}{a_1})&#x3D;1$。又有 $\operatorname{lcm}(x,b_0)&#x3D;b_1$，故 $\gcd(\dfrac{b_1}{x},\dfrac{b_1}{b_0})&#x3D;1$。且 $x\mid b_1$，枚举 $x$ 并判断即可，复杂度 $O(\sqrt{b_1} \log V)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a0, a1, b0, b1;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; a0 &gt;&gt; a1 &gt;&gt; b0 &gt;&gt; b1;<br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x * x &lt;= b1; x++) &#123;<br>		<span class="hljs-keyword">if</span> (b1 % x) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span> (x % a1 == <span class="hljs-number">0</span> &amp;&amp; __gcd(x / a1, a0 / a1) == <span class="hljs-number">1</span> &amp;&amp; __gcd(b1 / x, b1 / b0) == <span class="hljs-number">1</span>) cnt++;<br>		<span class="hljs-type">int</span> y = b1 / x;<br>		<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span> (y % a1 == <span class="hljs-number">0</span> &amp;&amp; __gcd(y / a1, a0 / a1) == <span class="hljs-number">1</span> &amp;&amp; __gcd(b1 / y, b1 / b0) == <span class="hljs-number">1</span>) cnt++;<br>	&#125;<br>	cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4549-【模板】裴蜀定理"><a href="#P4549-【模板】裴蜀定理" class="headerlink" title="P4549 【模板】裴蜀定理"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4549">P4549 【模板】裴蜀定理</a></h3><p>由 $\gcd(a,b,c)&#x3D;\gcd(a,\gcd(b, c))$ 和裴蜀定理得<br>$$<br>\sum_{i&#x3D;1}^{n} a_i x_i &#x3D; \gcd_{i&#x3D;1}^{n} |a_i|<br>$$<br>而题目中记 $\sum x_i$ 为 $S$，可知 $ \gcd_{i&#x3D;1}^{n} |a_i|$ 是 $S$ 的约数，$S$ 最小时二者相等。也就是求所有数的 $\gcd$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, res, a;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 两年前的马蜂</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a), a = <span class="hljs-built_in">abs</span>(a), res = __gcd(res, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CF510D-Fox-And-Jumping"><a href="#CF510D-Fox-And-Jumping" class="headerlink" title="CF510D Fox And Jumping"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF510D">CF510D Fox And Jumping</a></h3><p>根据裴蜀定理的推论，能跳到所有位置当且仅当我们选出的长度的 $\gcd&#x3D;1$。于是设 $dp_i$ 表示选择一些长度使得其最大公约数为 $i$ 的最小代价，采用刷表，枚举 $i,j \in [1,n]$ 易得<br>$$<br>dp_{\gcd(l_i, j)} \gets \min(dp_{\gcd(l_i, j)}, c_{i}+v)<br>$$<br>对于单个转移，有<br>$$<br>dp_{l_i} \gets \min(dp_{l_i},c_i)<br>$$<br>由于下标能到 $10^9$，暴力 dp 是不行的。但是有用的 $dp$ 值不多，于是我们用 <code>std::map</code> 维护转移，复杂度比较玄学。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">305</span>;<br><span class="hljs-type">int</span> n, l[N], c[N];<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dp;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!dp.<span class="hljs-built_in">count</span>(x)) dp[x] = v;<br>	<span class="hljs-keyword">else</span> dp[x] = <span class="hljs-built_in">min</span>(dp[x], v);<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; l[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; c[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; h : dp) &#123;<br>			<span class="hljs-type">int</span> j = h.first, v = h.second;<br>			<span class="hljs-built_in">upd</span>(__gcd(l[i], j), c[i] + v);<br>		&#125; <span class="hljs-built_in">upd</span>(l[i], c[i]);<br>	&#125;<br>	cout &lt;&lt; (dp.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) ? dp[<span class="hljs-number">1</span>] : <span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P1082-NOIP-2012-提高组-同余方程"><a href="#P1082-NOIP-2012-提高组-同余方程" class="headerlink" title="P1082 [NOIP 2012 提高组] 同余方程"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1082">P1082 [NOIP 2012 提高组] 同余方程</a></h3><p>这东西我们在之前的乘法逆元讲过方法了，就是用 exGCD 解方程 $ax-by&#x3D;1$。输入保证有解，意味着 $\gcd(a,b)&#x3D;1$，所以这就是 exGCD 方程的标准形式。细节上，求出 $x$ 以后要处理负数问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T&amp; x, T&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; a &gt;&gt; b;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, y; <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>	cout &lt;&lt; (x % b + b) % b;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P5656-【模板】二元一次不定方程-exgcd"><a href="#P5656-【模板】二元一次不定方程-exgcd" class="headerlink" title="P5656 【模板】二元一次不定方程 (exgcd)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5656">P5656 【模板】二元一次不定方程 (exgcd)</a></h3><p>首先由裴蜀定理判无解，若 $c$ 不是 $\gcd(a,b)$ 的倍数则直接无解。</p>
<p>设 $\gcd(a,b)&#x3D;d$。考虑用 exGCD 求解方程 $ax+by&#x3D;d$，将解记作 $x_0,y_0$。则<br>$$<br>ax_0+by_0&#x3D;d\<br>$$<br>方程两边同乘 $\dfrac{c}{d}$ 转化为所求：<br>$$<br>a\dfrac{cx_0}{d}+b\dfrac{cy_0}{d}&#x3D;c\<br>$$<br>故原方程的一组解为 $x_1&#x3D;\dfrac{cx_0}{d},y_1&#x3D;\dfrac{cy_0}{d}$。</p>
<p>接下来考虑构造通解形式，设<br>$$<br>a(x_1+m)+b(y_0+n)&#x3D;c<br>$$<br>不难发现 $m,n$ 满足条件 $am+bn&#x3D;0$。仍然利用裴蜀定理，解得 $m&#x3D;p \times \dfrac{b}{d}, n&#x3D;-p \times {a}{d}$，其中 $p$ 是正整数。于是我们得到原方程的通解<br>$$<br>\left{\begin{matrix}<br>x&#x3D;x_1+p \times \dfrac{b}{d} \<br>y&#x3D;y_1-p \times \dfrac{a}{d}<br>\end{matrix}\right.<br>$$<br>考虑求解数与最值。找 $x_{\min}$ 即为解关于 $k$ 的不等式<br>$$<br>x_1+km \ge 1<br>$$<br>由于式中的值均为整数，故<br>$$<br>k \ge \lceil \dfrac{1-x_1}{m} \rceil<br>$$<br>由于 $y$ 随 $x$ 的增大而减小，故 $x_{\min}$ 所对应的 $y$ 就是 $y_{\max}$。接下来我们用 $y_{\max}$ 推 $y_{\min}$。推导一下，可以发现<br>$$<br>y_{\min}&#x3D;y_{\max} \bmod n<br>$$<br>于是 $x_{\max}$ 加上同样多的 $m$ 即可：<br>$$<br>x_{\max}&#x3D;x_{\min} + \lfloor \dfrac{y_{\max}-1}{n} \times m \rfloor<br>$$<br>解数就是 $[y_{\min},y_{\max}]$ 中解的个数，即<br>$$<br>\lfloor \dfrac{y_{\max}-1}{n} +1 \rfloor<br>$$<br>至此本题在 $O(\log V)$ 内解决，$V$ 为值域。</p>
<p>在实现中，我们可以将 $a,b,c$ 都除去 $d$，这样可以简化代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T&amp; x, T&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, c;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> d = __gcd(a, b);<br>	<span class="hljs-keyword">if</span> (c % d) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">void</span>();<br>	a /= d, b /= d, c /= d;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x0, y0; <span class="hljs-built_in">exgcd</span>(a, b, x0, y0);<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x1 = c * x0, y1 = c * y0;<br>	<span class="hljs-type">int</span> xmin = (x1 &gt; <span class="hljs-number">0</span> &amp;&amp; x1 % b != <span class="hljs-number">0</span>) ? x1 % b : x1 % b + b;<br>	<span class="hljs-type">int</span> ymax = (c - xmin * a) / b;<br>	<span class="hljs-type">int</span> ymin = (y1 &gt; <span class="hljs-number">0</span> &amp;&amp; y1 % a != <span class="hljs-number">0</span>) ? y1 % a : y1 % a + a;<br>	<span class="hljs-type">int</span> xmax = (c - ymin * b) / a;<br>	<span class="hljs-keyword">if</span> (xmax &lt;= <span class="hljs-number">0</span>) cout &lt;&lt; xmin &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ymin &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; (ymax - ymin) / a + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; xmin &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ymin &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; xmax &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ymax &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P1516-青蛙的约会"><a href="#P1516-青蛙的约会" class="headerlink" title="P1516 青蛙的约会"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1516">P1516 青蛙的约会</a></h3><p>设相遇时两只青蛙跳了 $t$ 次，则<br>$$<br>(n-m)t+kL&#x3D;x-y<br>$$<br>即求解 $t$ 的最小非负整数解。在不定方程 $ax+by&#x3D;c$ 中，我们把 $n-m$ 视作 $a$，$L$ 视作 $b$，$x-y$ 视作 $c$，则应用上一题的方法来求解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T&amp; x, T&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x, y, m, n, L;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; L;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> a = n - m, b = L, c = x - y;<br>	<span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) a = -a, c = -c;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> d = __gcd(a, b);<br>	<span class="hljs-keyword">if</span> (c % d) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-string">&quot;Impossible&quot;</span>, <span class="hljs-built_in">void</span>();<br>	a /= d, b /= d, c /= d;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x0, y0; <span class="hljs-built_in">exgcd</span>(a, b, x0, y0);<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x1 = c * x0;<br>	cout &lt;&lt; ((x1 &gt; <span class="hljs-number">0</span> &amp;&amp; x1 % b != <span class="hljs-number">0</span>) ? x1 % b : x1 % b + b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4777-【模板】扩展中国剩余定理（EXCRT）"><a href="#P4777-【模板】扩展中国剩余定理（EXCRT）" class="headerlink" title="P4777 【模板】扩展中国剩余定理（EXCRT）"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4777">P4777 【模板】扩展中国剩余定理（EXCRT）</a></h3><p>这种解线性方程组的方法一般称作 exCRT。套用上面的 exGCD 法即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T&amp; x, T&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!b) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function">T <span class="hljs-title">crt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> T* a, <span class="hljs-type">const</span> T* m)</span> </span>&#123;<br>	T x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, p = m[<span class="hljs-number">1</span>], res = a[<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		T a0 = p, b0 = m[i], c = (a[i] - res % b0 + b0) % b0, g = __gcd(a0, b0);<br>		<span class="hljs-keyword">if</span> (c % g) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		<span class="hljs-built_in">exgcd</span>(a0, b0, x, y);<br>		x = (__int128) x * c / g % b0, res += x * p, p = p / __gcd(p, b0) * b0, res = (res % p + p) % p;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[N], m[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; m[i] &gt;&gt; a[i];<br>	cout &lt;&lt; <span class="hljs-built_in">crt</span>(n, a, m);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>exCRT 很重要的一个用途是对于模数不是质数的情况，我们把模数分解质因数，然后分别计算对这些质因数取模的结果，最后用 exCRT 合并。</p>
<h3 id="P3868-TJOI2009-猜数字"><a href="#P3868-TJOI2009-猜数字" class="headerlink" title="P3868 [TJOI2009] 猜数字"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3868">P3868 [TJOI2009] 猜数字</a></h3><p>对于 $(x-a_i) \mid  b_i$，可以变形为 $x-a_i \equiv 0 \pmod {b_i}$，然后再移项就是 $x \equiv a_i \pmod {b_i}$。于是解这个同余方程组即可。</p>
<p>细节上注意 $a_i$ 可能为负，需要对 $b_i$ 取模处理，另外这题会爆 <code>long long</code>，不过上面板子里已经开了 <code>__int128</code> 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[N], b[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = (a[i] % b[i] + b[i]) % b[i];<br>	cout &lt;&lt; <span class="hljs-built_in">crt</span>(n, a, b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>欧拉函数 $\varphi(x)$ 指 $[1,n]$ 中与 $n$ 互质的数的个数。</p>
<p>若由算术基本定理可将 $n$ 分解为 $p_1^{c_1} p_2^{c_2} p_3^{c_3} \cdots p_m^{c_m}$，则</p>
<p>$$<br>\varphi(x)&#x3D;n (1-\dfrac{1}{p_1})  (1-\dfrac{1}{p_2}) (1-\dfrac{1}{p_3}) \cdots (1-\dfrac{1}{p_m}) &#x3D;n\times \prod_{i&#x3D;1}^{m} (1-\dfrac{1}{p_i})<br>$$</p>
<p>由此有一个 $O(\sqrt{n})$ 计算欧拉函数的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> res = n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>			res = res / i * (i - <span class="hljs-number">1</span>);<br>			<span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) res = res / n * (n - <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>性质 1：若 $p$ 是质数，则 $\varphi(p)&#x3D;p-1$。</p>
<p>性质 2：若 $a,b$ 互质，则 $\varphi(ab)&#x3D;\varphi(a) \times \varphi(b)$。这表明：欧拉函数是积性函数，因而可以用线性筛筛出。</p>
<p>性质 3：$\sum_{d \mid  n} \varphi(d)&#x3D;n$。</p>
<p>性质 4：对于 $n&gt;1$，$[1,n]$ 中与 $n$ 互质的数的和为 $\dfrac{1}{2}n\times \varphi(n)$。</p>
<p>性质 5：若 $n&#x3D;p^k$，其中 $p$ 是质数，则 $\varphi(n)&#x3D;p^k-p^{k-1}$。</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><p>使用性质 2 并结合线性筛法，可以在 $O(n)$ 时间内预处理 $[1,n]$ 的欧拉函数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> len, phi[N], prime[N];<br>bitset&lt;N&gt; isprime;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">eular</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, isprime.<span class="hljs-built_in">set</span>(), isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (isprime[i]) prime[++len] = i, phi[i] = i - <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len &amp;&amp; i * prime[j] &lt;= n; j++) &#123;<br>			isprime[i * prime[j]] = <span class="hljs-literal">false</span>;<br>			<span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>				phi[i * prime[j]] = phi[i] * prime[j];<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			phi[i * prime[j]] = phi[i] * phi[prime[j]];<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="SP4141-ETF-Euler-Totient-Function"><a href="#SP4141-ETF-Euler-Totient-Function" class="headerlink" title="SP4141 ETF - Euler Totient Function"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP4141">SP4141 ETF - Euler Totient Function</a></h3><p>线性筛欧拉函数板子。直接上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">void</span> _main() &#123;<br>	<span class="hljs-built_in">eular</span>(N - <span class="hljs-number">1</span>);<br>	<span class="hljs-type">int</span> t, x; cin &gt;&gt; t;<br>	<span class="hljs-keyword">while</span> (t--) cin &gt;&gt; x, cout &lt;&lt; phi[x] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="UVA10179-Irreducable-Basic-Fractions"><a href="#UVA10179-Irreducable-Basic-Fractions" class="headerlink" title="UVA10179 Irreducable Basic Fractions"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA10179">UVA10179 Irreducable Basic Fractions</a></h3><p>题意翻译：求 $\dfrac{0}{n},\dfrac{1}{n},\dfrac{2}{n},\cdots \dfrac{n-1}{n}$ 中多少个分数为最简分数。认为 $\dfrac{0}{n}$ 最简。</p>
<p>我们发现最简分数 $\dfrac{x}{n}$ 满足 $\gcd(x,n)&#x3D;1$，于是所求为 $\varphi(n)$。用分解质因数法求即可，代码不放了。</p>
<h3 id="P2158-SDOI2008-仪仗队"><a href="#P2158-SDOI2008-仪仗队" class="headerlink" title="P2158 [SDOI2008] 仪仗队"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2158">P2158 [SDOI2008] 仪仗队</a></h3><p>由样例图可以发现能看见的位置关于对角线对称，只需要考虑一个三角形即可。以左下角为原点 $(0,0)$ 建立坐标系，则一个点被阻挡的条件就是到原点连线的斜率相同。设两点 $(x_1,y_1),(x_2,y_2)$，则 $\dfrac{y_1}{x_1}&#x3D;\dfrac{y_2}{x_2}$。当且仅当这个分数已经为最简形式时它不会被挡住，这就和上题类似了。</p>
<p>所求即为<br>$$<br>2\sum_{i&#x3D;1}^{n-1} \varphi(i)+1<br>$$<br>这是因为 $(2,2)$ 满足条件而我们无法统计进去。注意特判 $n&#x3D;1$。</p>
<p>用线性筛筛出欧拉函数即可，复杂度 $O(n)$，代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">eular</span>(<span class="hljs-number">40000</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) res += <span class="hljs-number">2</span> * phi[i];<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2398-GCD-SUM"><a href="#P2398-GCD-SUM" class="headerlink" title="P2398 GCD SUM"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2398">P2398 GCD SUM</a></h3><p>这题做法很多，读者可以翻到下文容斥例题学习容斥做法，这里写的是欧拉函数做法。</p>
<p>可以发现 $\gcd(i,j)$ 的值只有 $n$ 种，不妨考虑 $gcd(i,j)&#x3D;k$ 的数目。对于一对互质的 $i,j$，有 $\gcd(ik,jk)&#x3D;k$，所以可以得到结果为 $k$ 的数目为<br>$$<br>2\sum_{i&#x3D;1}^{\lfloor \frac{n}{k} \rfloor} \varphi(i)-1<br>$$<br> 和上面那题是一样的，因为 $\gcd(i,j)&#x3D;\gcd(j,i)$ 有对称性，而 $(1,1)$ 会重复计算，要减一。</p>
<p>然后我们用线性筛处理出 $\varphi(i)$ 的前缀和，$O(n)$ 计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> pre[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-built_in">eular</span>(n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) pre[i] = pre[i - <span class="hljs-number">1</span>] + phi[i];<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += <span class="hljs-number">1LL</span> * i * (<span class="hljs-number">2</span> * pre[n / i] - <span class="hljs-number">1</span>);<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双倍经验：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1390">P1390</a>。这个题没有对称性，把系数 $2$ 去掉即可。</p>
<h1 id="数论常用定理"><a href="#数论常用定理" class="headerlink" title="数论常用定理"></a>数论常用定理</h1><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若 $p$ 为质数，且 $\gcd(a,p)&#x3D;1$，则 $a^{p-1} \equiv 1 \pmod p$。</p>
<p>变形式：$a^p\equiv a \pmod p$ 和 $a^{p-2}\equiv \dfrac{1}{a} \pmod p$。其中第二个式子表明，当 $p$ 为质数时可以直接用快速幂求逆元。</p>
<p>证明：取一个不为 $p$ 的倍数的数 $a$，构造序列 $A&#x3D;{1,2,3, \cdots p-1}$，则：</p>
<p>$$<br>\prod_{i&#x3D;1}^{p-1} A_i \equiv \prod_{i&#x3D;1}^{p-1} (A_i\times a) \pmod p<br>$$<br>考虑每一个 $A_i$ 都不是 $p$ 的约数易证。则令 $m&#x3D;(p-1)!$，则<br>$$<br>m \equiv \prod_{i&#x3D;1}^{p-1} (A_i\times a) \pmod p<br>$$<br>又有 $a^{p-1} \times f \equiv f \pmod p$，故<br>$$<br>a^{p-1} \equiv 1 \pmod p<br>$$</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉定理是费马小定理的扩展形式。若 $\gcd(a,n)&#x3D;1$，则 $a^{\varphi(n)} \equiv 1 \pmod n$。证明与费马小定理类似，构造一个与 $n$ 互质的序列即可。</p>
<h3 id="推论-2"><a href="#推论-2" class="headerlink" title="推论"></a>推论</h3><p>推论 1：若 $\gcd(a,n)&#x3D;1$，则 $a^b \equiv a^{b \bmod \varphi(n)} \pmod n$。</p>
<p>推论 2：若 $\gcd(a,n)&#x3D;1$，则满足 $a^x \equiv 1 \pmod n$ 的最小正整数是 $\varphi(n)$ 的约数。</p>
<h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h2><p>扩展欧拉定理在 OI 中常用于对幂取模的情况。<br>$$<br>a^b \equiv \left{\begin{matrix}<br> a^{b \bmod \varphi(n)} &amp; \gcd(a,n)&#x3D;1 \<br> a^b &amp; \gcd(a,n) \ne 1,b &lt; \varphi(n) \<br> a^{(b \bmod \varphi(n))+\varphi(n)} &amp; \gcd(a,n) \ne 1, b \ge \varphi(n)<br>\end{matrix}\right. \pmod n<br>$$</p>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><h3 id="P4139-上帝与集合的正确用法"><a href="#P4139-上帝与集合的正确用法" class="headerlink" title="P4139 上帝与集合的正确用法"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4139">P4139 上帝与集合的正确用法</a></h3><p>题里给的那个东西实际上是 $2^{2^{2^{2^ \cdots}}} \bmod p$。对指数塔不断递归，用扩展欧拉定理降幂即可。$\varphi(n)$ 提前筛出来。</p>
<p>由于指数塔是无限层，因此肯定有 $b \ge \varphi(n)$，直接认为是第三种情况就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> p;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (a %= p; b; a = a * a % p, b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> p == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">power</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">f</span>(phi[p]) + phi[p], p);&#125;<br><br><span class="hljs-type">void</span> _main() &#123;   <span class="hljs-comment">// 这里已经筛过phi[n]了</span><br>	cin &gt;&gt; p; cout &lt;&lt; <span class="hljs-built_in">f</span>(p) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P10496-The-Luckiest-Number"><a href="#P10496-The-Luckiest-Number" class="headerlink" title="P10496 The Luckiest Number"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10496">P10496 The Luckiest Number</a></h3><p>设答案为 $x$ 个 $8$ 连在一起的整数 $n$，由等比数列求和<br>$$<br>\begin{aligned}<br>n&amp;&#x3D;8+8\times 10+8\times 10^2 + \cdots + 8 \times 10^x\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{x} 8 \times 10^i \<br>&amp;&#x3D;\dfrac{8(10^x-1)}{9}<br>\end{aligned}<br>$$<br>设 $d&#x3D;\gcd(L,8)$，则由题知 $L \mid \dfrac{8(10^x-1)}{9}$，故 $9L \mid 8(10^x-1)$，即<br>$$<br>\dfrac{9L}{d} \mid  (10^x-1)<br>$$<br>因此，$10^ x \equiv 1 \pmod {\dfrac{9L}{d}}$。</p>
<p>由欧拉定理的推论 2，我们求出 $\varphi(\dfrac{9L}{d})$ 并枚举其约数检查即可，复杂度 $O(\sqrt{L} \log L)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (a %= p; b; a = (__int128) a * a % p, b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = (__int128) res * a % p;<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">factors</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>	vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; res;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>		res.<span class="hljs-built_in">emplace_back</span>(i);<br>		<span class="hljs-keyword">if</span> (n / i != i) res.<span class="hljs-built_in">emplace_back</span>(n / i);<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> kase = <span class="hljs-number">1</span>; ; kase++) &#123;<br>		cin &gt;&gt; n;<br>		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; kase &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>		n = <span class="hljs-number">9</span> * n / __gcd(n, <span class="hljs-number">8LL</span>);<br>		<span class="hljs-keyword">if</span> (__gcd(n, <span class="hljs-number">10LL</span>) != <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>; <span class="hljs-keyword">continue</span>;&#125;<br>		vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; f = <span class="hljs-built_in">factors</span>(<span class="hljs-built_in">phi</span>(n));<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> x : f) &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">power</span>(<span class="hljs-number">10</span>, x, n) == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">break</span>;&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2480-SDOI2010-古代猪文"><a href="#P2480-SDOI2010-古代猪文" class="headerlink" title="P2480 [SDOI2010] 古代猪文"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2480">P2480 [SDOI2010] 古代猪文</a></h3><p>我们先形式化题意，就是要求<br>$$<br>g^{\sum_{d \mid n} C_n^d} \bmod 999911659<br>$$<br>首先你打个 $O(\sqrt{n})$ 判质数，发现 $999911659$ 是质数，由欧拉定理的推论 1<br>$$<br>g^{\sum_{d \mid n} C_n^d} \equiv g^{\sum_{d \mid n} C_n^d \bmod \varphi(999911659)} \pmod {999911659}<br>$$<br>由欧拉函数性质 1，$\varphi(999911659)&#x3D;999911659-1&#x3D;999911658$，因此<br>$$<br>g^{\sum_{d \mid n} C_n^d} \equiv g^{\sum_{d \mid n} C_n^d \bmod 999911658} \pmod {999911659}<br>$$<br>所以只需求 $\sum_{d \mid n} C_n^d \bmod 999911658$ 然后快速幂即可。如果直接上 exLucas，复杂度会爆炸，考虑怎么做。我们打一个 $O(\sqrt{n})$ 试除法分解质因数可得<br>$$<br>999911658&#x3D;2\times 3 \times 4679 \times 35617<br>$$<br>用 $O(\sqrt{n})$ 枚举 $d \mid n$，然后使用 Lucas 定理计算 $C^{d}_n$ 对 $2,3,4679,35617$ 取模的结果，然后 exCRT 合并答案即可。如果你还不会 Lucas 定理求组合数，请移步下文学习后再看代码。</p>
<p>特别要注意，欧拉定理成立的条件是 $\gcd(g,999911659)&#x3D;1$，若不成立要判无解，以及 exCRT 也要判无解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">int</span> n, g;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (a %= p; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>		a = a * a % p;<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> Lucas &#123;<br>	<span class="hljs-type">int</span> fac[N], ifac[N];<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>		fac[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">1</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= p; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i % p, ifac[i] = <span class="hljs-built_in">power</span>(fac[i], p - <span class="hljs-number">2</span>, p);<br>	&#125; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> fac[n] * ifac[m] % p * ifac[n - m] % p; <br>	&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (n &lt; p &amp;&amp; m &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(n, m, p);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">lucas</span>(n / p, m / p, p) * <span class="hljs-built_in">C</span>(n % p, m % p, p) % p;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> CRT &#123;<br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(T a, T b, T&amp; x, T&amp; y)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!b) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>		<span class="hljs-built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;<br>	&#125;<br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function">T <span class="hljs-title">crt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> T* a, <span class="hljs-type">const</span> T* m)</span> </span>&#123;<br>		T x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, p = m[<span class="hljs-number">1</span>], res = a[<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>			T a0 = p, b0 = m[i], c = (a[i] - res % b0 + b0) % b0, g = __gcd(a0, b0);<br>			<span class="hljs-keyword">if</span> (c % g) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>			<span class="hljs-built_in">exgcd</span>(a0, b0, x, y);<br>			x = (__int128) x * c / g % b0, res += x * p, p = p / __gcd(p, b0) * b0, res = (res % p + p) % p;<br>		&#125;<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4679</span>, <span class="hljs-number">35617</span>&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; g;<br>	<span class="hljs-keyword">if</span> (__gcd(g, <span class="hljs-number">999911659LL</span>) != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();  <span class="hljs-comment">// 注意判无解</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>		Lucas::<span class="hljs-built_in">init</span>(P[i]);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d * d &lt;= n; d++) &#123;<br>			<span class="hljs-keyword">if</span> (n % d) <span class="hljs-keyword">continue</span>;<br>			a[i] = (a[i] + Lucas::<span class="hljs-built_in">lucas</span>(n, d, P[i])) % P[i];<br>			<span class="hljs-keyword">if</span> (n / d != d) a[i] = (a[i] + Lucas::<span class="hljs-built_in">lucas</span>(n, n / d, P[i])) % P[i];<br>		&#125; <br>	&#125; <br>	<span class="hljs-type">int</span> val = CRT::<span class="hljs-built_in">crt</span>(<span class="hljs-number">4</span>, a, P);<br>	<span class="hljs-keyword">if</span> (val == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();  <span class="hljs-comment">// 注意判无解</span><br>	cout &lt;&lt; <span class="hljs-built_in">power</span>(g, val, <span class="hljs-number">999911659</span>);<br>&#125; <br></code></pre></td></tr></table></figure>

<p>这个题基本把我们讲过的数论知识都用了一遍，是一道很全面很综合的好题。</p>
<h1 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h1><p>数论分块用于快速计算形如</p>
<p>$$<br>\sum_{i&#x3D;1}^{n} f(i) g(\lfloor \dfrac{k}{i} \rfloor)<br>$$</p>
<p>的式子，其中 $f(i)$ 可处理出前缀和或可以快速计算 $f(x)-f(y)$。如果这是 $O(1)$ 的，则数论分块可在 $O(\sqrt{n})$ 的时间内得出结果。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>以函数 $y&#x3D;\lfloor \dfrac{100}{x} \rfloor$ 为例，图像如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xsvja4az.png" srcset="/img/loading.gif" lazyload></p>
<p>我们注意到对于每个固定的 $y$，$x$ 的取值总是一个固定区间。事实上，$\lfloor \dfrac{k}{i} \rfloor$ 不变时，$i \le \lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor$。</p>
<p>设 $m&#x3D;\lfloor \dfrac{k}{i} \rfloor$，则 $m \le \dfrac{k}{i}$，所以 $\lfloor \dfrac{k}{m} \rfloor \ge \lfloor \frac{k}{\frac{k}{i}} \rfloor&#x3D;i$。</p>
<p>因此，$i_{\max}&#x3D;\lfloor \dfrac{k}{m} \rfloor&#x3D;\lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor$。</p>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F_t</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">G_t</span>&gt;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sqrt_decomposition</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k, F_t f, G_t g)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>		r = (k / l) ? <span class="hljs-built_in">min</span>(n, (k / (k / l))) : n;<br>		res += <span class="hljs-built_in">f</span>(r, l - <span class="hljs-number">1</span>) * <span class="hljs-built_in">g</span>(k / l);<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个板子第一个参数传入 $n$，第二个参数传入 $k$，第三个参数传入一个函数计算 $f(x)-f(y)$，第四个参数传入 $g(x)$ 的函数。</p>
<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><h3 id="UVA11526-H-n"><a href="#UVA11526-H-n" class="headerlink" title="UVA11526 H(n)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11526">UVA11526 H(n)</a></h3><p>【模板】数论分块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	cout &lt;&lt; <span class="hljs-built_in">sqrt_decomposition</span>(n, n,<br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> y) &#123;<span class="hljs-keyword">return</span> x - y;&#125;, <span class="hljs-comment">// f(x) = 1</span><br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-comment">// g(x) = x</span><br>	) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2424-约数和"><a href="#P2424-约数和" class="headerlink" title="P2424 约数和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2424">P2424 约数和</a></h3><p>首先考虑求 $f(x)$ 的前缀和 $g(x)$。有一个结论是 $i$ 的约数在 $n$ 以内有 $\lfloor \dfrac{n}{i} \rfloor$ 个，所以</p>
<p>$$<br>g(x) &#x3D; \sum_{i&#x3D;1}^{n} i \times \lfloor \dfrac{n}{i} \rfloor<br>$$</p>
<p>然后套板子去求即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt_decomposition</span>(n, n, <br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;,<br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> x;&#125;<br>	);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l, r;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; l &gt;&gt; r;<br>	cout &lt;&lt; <span class="hljs-built_in">g</span>(r) - <span class="hljs-built_in">g</span>(l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2261-CQOI2007-余数求和"><a href="#P2261-CQOI2007-余数求和" class="headerlink" title="P2261 [CQOI2007] 余数求和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2261">P2261 [CQOI2007] 余数求和</a></h3><p>根据取模的定义，有 $a \bmod b&#x3D;a-b \times \lfloor \dfrac{a}{b} \rfloor$，然后推一波式子：</p>
<p>$$<br>\begin{aligned}<br>G(n, k) &amp;&#x3D; \sum_{i &#x3D; 1}^n k \bmod i \<br>&amp;&#x3D; \sum_{i &#x3D; 1}^n k -i \times \lfloor \dfrac{k}{b} \rfloor \<br>&amp;&#x3D; nk-\sum_{i &#x3D; 1}^n i \times \lfloor \dfrac{k}{b} \rfloor<br>\end{aligned}<br>$$</p>
<p>后面这个东西可以数论分块来做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, k;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	cout &lt;&lt; n * k - <span class="hljs-built_in">sqrt_decomposition</span>(n, k, <br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;, <span class="hljs-comment">// f(x) = x</span><br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-comment">// g(x) = x</span><br>	);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2260-清华集训-2012-模积和"><a href="#P2260-清华集训-2012-模积和" class="headerlink" title="P2260 [清华集训 2012] 模积和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2260">P2260 [清华集训 2012] 模积和</a></h3><p>和上面的题很像。</p>
<p>推柿子：</p>
<p>$$<br>\begin{aligned}<br>ans &amp;&#x3D;\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{m} (n \bmod i) \times (m \bmod j), i \neq j  \</p>
<p>&amp;&#x3D;\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{m} (n \bmod i) \times (m \bmod j)-\sum_{i&#x3D;1}^{\min(n,m)} (n \bmod i) \times (m \bmod i)\</p>
<p>&amp;&#x3D;\sum_{i&#x3D;1}^n(n-\lfloor\frac{n}{i}\rfloor\times i)\times\sum_{j&#x3D;1}^m(m-\lfloor\frac{m}{j}\rfloor\times j)-\sum_{i&#x3D;1}^{\min(n,m)}(n-\lfloor\frac{n}{i}\rfloor\times i)\times(m-\lfloor\frac{m}{i}\rfloor\times i)\</p>
<p>&amp;&#x3D;(n^2-\sum_{i&#x3D;1}^ni\times\lfloor\frac{n}{i}\rfloor)\times(m^2-\sum_{i&#x3D;1}^mi\times\lfloor\frac{m}{i}\rfloor)-\sum_{i&#x3D;1}^{\min(n,m)}(nm-mi\times\lfloor\frac{n}{i}\rfloor-ni\times\lfloor\frac{m}{i}\rfloor+i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)\</p>
<p>&amp;&#x3D;(n^2-\sum_{i&#x3D;1}^ni\times\lfloor\frac{n}{i}\rfloor)\times(m^2-\sum_{i&#x3D;1}^mi\times\lfloor\frac{m}{i}\rfloor)-nm\times \min(n,m)+\sum_{i&#x3D;1}^{\min(n,m)}mi\times\lfloor\frac{n}{i}\rfloor+\sum_{i&#x3D;1}^{\min(n,m)} ni\times\lfloor\frac{m}{i}\rfloor -\sum_{i&#x3D;1}^{\min(n,m)}  i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor<br>\end{aligned}<br>$$</p>
<p>最后这个 $i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor$ 用数论分块的时候不太一样。首先我们需要保证块内的 $\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor$ 相同，将右端点改为 $\min(\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor,\lfloor \frac{m}{\lfloor \frac{m}{i} \rfloor} \rfloor)$，这叫做二维数论分块。然后用到结论 $\sum_{i&#x3D;1}^{n} i^2&#x3D;\frac{n(n+1)(2n+1)}{6}$。不了解这个结论可以翻到下文数列求和结论 1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m;<br><span class="hljs-function">modint <span class="hljs-title">pre</span><span class="hljs-params">(modint n)</span> </span>&#123;<span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) * (n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) / <span class="hljs-built_in">modint</span>(<span class="hljs-number">6</span>);&#125;<br><span class="hljs-function">modint <span class="hljs-title">k1</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 这里没法套板子，自己写一个</span><br>	modint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; l &lt;= <span class="hljs-built_in">min</span>(n, m); l = r + <span class="hljs-number">1</span>) &#123;<br>		r = <span class="hljs-built_in">min</span>(n / (n / l), m / (m / l));<br>		res += <span class="hljs-built_in">modint</span>(n / l) * <span class="hljs-built_in">modint</span>(m / l) * (<span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l - <span class="hljs-number">1</span>));<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m; <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-built_in">min</span>(n, m);<br>	modint n0 = n, m0 = m;<br>	modint n1 = n0 * n0 - <span class="hljs-built_in">sqrt_decomposition</span>(n, n,<br>		[](modint x, modint y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;, <br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> x;&#125; <br>	);<br>	modint m1 = m0 * m0 - <span class="hljs-built_in">sqrt_decomposition</span>(m, m,<br>		[](modint x, modint y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;, <br>		[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> x;&#125;<br>	);<br>	modint n2 = <span class="hljs-built_in">sqrt_decomposition</span>(k, n, <br>		[](modint x, modint y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;, <br>		[&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> m0 * x;&#125;<br>	);<br>	modint m2 = <span class="hljs-built_in">sqrt_decomposition</span>(k, m, <br>		[](modint x, modint y) &#123;<span class="hljs-built_in">return</span> (x - y) * (x + y + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;, <br>		[&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<span class="hljs-keyword">return</span> n0 * x;&#125;<br>	);<br>	cout &lt;&lt; n1 * m1 - n0 * m0 * k + n2 + m2 - <span class="hljs-built_in">k1</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="加法-乘法原理"><a href="#加法-乘法原理" class="headerlink" title="加法 &amp; 乘法原理"></a>加法 &amp; 乘法原理</h1><ul>
<li>加法原理：有 $n$ 类方法，$a_i$ 为第 $i$ 类中方法的数目，则总方法数为 $\sum a_i$。</li>
<li>乘法原理：有 $n$ 个步骤，$a_i$ 为第 $i$ 步中方法的数目，则总方法数为 $\prod a_i$。</li>
</ul>
<p>这两者的区别是：加法分类，乘法分步。</p>
<p>加法原理有一个推论，即减法原理，就是求满足某种约束的方案数可以用总方案数减去不满足约束的方案数。这是最简单的容斥，是“正难则反”的体现。</p>
<h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p>在应用加法 &amp; 乘法原理推公式的时候，常会用到数列求和相关知识，故在此补充。</p>
<h3 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h3><p>等差数列是指满足递推式 $a_i-a_{i-1}&#x3D;d$ 的数列，其中 $d$ 为常数，称作公差。由递推公式逐级写出：<br>$$<br>a_2-a_1&#x3D;d\<br>a_3-a_2&#x3D;d\<br>\cdots\<br>a_{i}-a_{i-1}&#x3D;d<br>$$<br>然后两边相加，得<br>$$<br>a_i&#x3D;a_1+(i-1)d<br>$$<br>此为等差数列通项公式。移项可得公差计算方法<br>$$<br>d&#x3D;\dfrac{a_i-a_1}{i-1}<br>$$<br>等差数列求和是 OI 数学题常用方法。下面我们对其作推导。设<br>$$<br>S&#x3D;a_1+a_2+\cdots+a_n<br>$$<br>将其复制一份倒序相加<br>$$<br>S&#x3D;a_n+\cdots+a_2+a_1\<br>2S&#x3D;(a_1+a_n)+(a_2+a_{n-1})+\cdots+(a_n+a_1)&#x3D;n(a_1+a_n)<br>$$<br>因而<br>$$<br>S&#x3D;\dfrac{a_1+a_n}{2}&#x3D;na_1+\dfrac{dn(n-1)}{2}<br>$$</p>
<h3 id="等比数列"><a href="#等比数列" class="headerlink" title="等比数列"></a>等比数列</h3><p>等差数列是指满足递推式 $\dfrac{a_i}{a_{i-1}}&#x3D;q$ 的数列，其中 $q$ 为常数，称作公比。类似等差数列的方法可得其递推公式<br>$$<br>a_i&#x3D;a_1 \times q^{i-1}<br>$$<br>仍然来推求和公式。设<br>$$<br>S&#x3D;a_1+qa_1+q^2a_1 + \cdots + q^na_1<br>$$<br>采用错位相减法<br>$$<br>qS&#x3D;qa_1+q^2a_1+q^3a_1+\cdots+q^{n+1}a_1\<br>qS-S&#x3D;q^{n+1}a_1-a_1<br>$$<br>因此<br>$$<br>S&#x3D;\dfrac{(q^{n+1}-1)a_1}{q-1}<br>$$</p>
<h4 id="分治求和法"><a href="#分治求和法" class="headerlink" title="分治求和法"></a>分治求和法</h4><p>如果等比数列在模意义下求和，就需要求 $q-1$ 的逆元，而若 $q-1$ 无逆元，则无法套公式。这里介绍一种类似快速幂的分治求和方法，复杂度 $O(\log^2 n)$。</p>
<p>记 $sum(k,n)&#x3D;1+k+k^2+\cdots+k^{n-1}$。若 $n$ 为偶数，将 $sum(k,n)$ 分为 $1+k+k^2+\cdots+k^{n&#x2F;2-1}$ 与 $k^{n&#x2F;2}+\cdots+k^{n-2}+k^{n-1}$ 两部分，则<br>$$<br>\begin{aligned}<br>sum(k,n)&amp;&#x3D;1+k+k^2+\cdots+k^n \<br>&amp;&#x3D; 1+k+k^2+\cdots+k^{n&#x2F;2-1}+k^{n&#x2F;2}+\cdots+k^{n-2}+k^{n-1} \<br>&amp;&#x3D; 1+k+k^2+\cdots+k^{n&#x2F;2-1} + k^{n&#x2F;2}(1+k+k^2+\cdots+k^{n&#x2F;2-1}) \<br>&amp;&#x3D; (k^{n&#x2F;2}+1) (1+k+k^2+\cdots+k^{n&#x2F;2-1}) \<br>&amp;&#x3D; (k^{n&#x2F;2}+1) \times sum(k,n&#x2F;2)<br>\end{aligned}<br>$$<br>而若 $n$ 为奇数，则 $n-1$ 为偶数，$sum(k,n)&#x3D;sum(k,n-1) + k^{n-1}$。递归出口 $sum(k,1)&#x3D;1$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-built_in">sum</span>(k, n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">mpow</span>(k, n - <span class="hljs-number">1</span>)) % p;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(k, n &gt;&gt; <span class="hljs-number">1</span>) * (<span class="hljs-built_in">mpow</span>(k, n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) % p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自己造的板子：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U588919">U588919</a>。</p>
<h3 id="幂数列求和"><a href="#幂数列求和" class="headerlink" title="幂数列求和"></a>幂数列求和</h3><p>这里再补充一些幂数列求和的结论。幂数列是形如 $a_i&#x3D;i^k$ 的数列，$k$ 为正整数。</p>
<p><strong>结论 1：</strong><br>$$<br>\sum_{i&#x3D;1}^{n} i &#x3D; 1+ 2+3+\cdots+n&#x3D;\dfrac{n(n+1)}{2}<br>$$<br>等差数列求和的最简单情况，相当常用。$\dfrac{n(n+1)}{2}$ 这个东西叫做三角形数。</p>
<p><strong>结论 2：</strong><br>$$<br>\sum_{i&#x3D;1}^{n}i^2 &#x3D; 1^2+2^2+3^2+\cdots+n^2&#x3D;\dfrac{n(n+1)(2n+1)}{6}<br>$$<br>用数学归纳法证。显然 $n&#x3D;1$ 时是成立的。考虑 $n&#x3D;k$ 时等式成立，只需证 $n&#x3D;k+1$ 时等式也成立，即<br>$$<br>1^2+2^2+3^2+\cdots+k^2+(k+1)^2<br>&#x3D;\dfrac{k(k+1)(2k+1)}{6}+\dfrac{6(k+1)^2}{6}<br>&#x3D;\dfrac{(k+1)(k+3)(2k+3)}{6}<br>$$<br>因此结论正确。平方数列求和的这个结果 $\dfrac{n(n+1)(2n+1)}{6}$ 又叫做四角锥数。</p>
<p><strong>结论 3：</strong><br>$$<br>\sum_{i&#x3D;1}^{n} i^3&#x3D;1^3+2^3+3^3+\cdots+n^3&#x3D;(1+2+3+\cdots+n)^2&#x3D;[\dfrac{n(n+1)}{2}]^2<br>$$<br>更高次幂的求和一般不常用。</p>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>容斥原理是加法 &amp; 减法原理的推广。</p>
<p>用一个例题引入：假设班里有 $a$ 个学生喜欢语文，$b$ 个学生喜欢数学，$c$ 个数学喜欢英语，则 班里至少喜欢一门学科的有多少个学生？</p>
<p>显然你不能简单地用 $a+b+c$ 计算，因为可以有学生同时喜欢两门甚至三门学科。我们使用集合论语言，设喜欢三门学科的学生集合为 $A,B,C$，则所求为 $|A \cup B \cup C|$。因为 $|A|+|B|+|C|&#x3D;a+b+c$ 这样会把同时喜欢两个学科的人算重，需要减去 $|A \cap B|+|A \cap C|+ |B \cap C|$。然而这样又会把同时喜欢三个学科的人减去，所以又要加上 $|A \cap B \cap C|$。于是答案为<br>$$<br>|A \cup B \cup C|&#x3D;|A|+|B|+|C|-|A \cap B|-|A \cap C|-|B\cap C|+|A \cup B \cup C|<br>$$<br>这就是三元容斥。它有多元的扩展形式，请读者自行思考。</p>
<p>用到容斥的地方其实很多，减法原理就是最简单的容斥，高维前缀和也有容斥做法，可持久化线段树所使用的 $[l,r]&#x3D;[1,r]-[1,l-1]$ 也可以用容斥解释。</p>
<h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><h3 id="P3197-HNOI2008-越狱"><a href="#P3197-HNOI2008-越狱" class="headerlink" title="P3197 [HNOI2008] 越狱"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3197">P3197 [HNOI2008] 越狱</a></h3><p>由减法原理，可以用总数目减去不会越狱的数目。</p>
<p>本题中，$n$ 个人都有 $m$ 种选择，由乘法原理可得总数目为 $m^n$。接着我们考虑合法方案，第一个位置能放 $m$ 个，而第二个位置在第一位没有选的 $m-1$ 个中选一个，由此递推，可得方案数为 $m(m-1)^{n-1}$。所以所求为 $m^n-m(m-1)^{n-1}$，并且要写个快速幂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">100003</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (a %= mod; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>		a = a * a % mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; m &gt;&gt; n;<br>	cout &lt;&lt; ((<span class="hljs-built_in">power</span>(m, n) - m * <span class="hljs-built_in">power</span>(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)) % mod + mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CF1207D-Number-Of-Permutations"><a href="#CF1207D-Number-Of-Permutations" class="headerlink" title="CF1207D Number Of Permutations"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1207D">CF1207D Number Of Permutations</a></h3><p>考察好序列的性质，发现不太好计数，于是我们用容斥把它拆开，所求变为：总方案数 $-$ 第一维 $a_i$ 有序的方案数 $-$ 第二维 $b_i$ 有序的方案数 $+$ 两维 $a_i,b_i$ 同时有序的方案数。</p>
<p>显然总方案数是 $n!$。对于单维有序的情况，$a_i,b_i$ 同理，这里只讨论 $a_i$。先完成排序后每一块相同的数可以任意交换，于是我们开个桶来计数，由乘法原理可知答案是 $\prod_{i&#x3D;1}^{n} cnt_i!$。两维同时有序，和上述类似，我们用桶 $p_{i,j}$ 记录数对 $(i,j)$ 的出现次数，所求为 $\prod_{i&#x3D;1}^{n} p_{a_i,b_i}$。于是我们预处理阶乘即可。</p>
<p>但是要注意两维同时有序可能无解，需要排个序特判一波。</p>
<blockquote>
<p>以及：CF 有 hack 机制能用 unordered_map 吗？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">using</span> p32 = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br>mint fac[N];<br><span class="hljs-type">int</span> n, a, b;<br>p32 h[N];<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt1, cnt2;<br>map&lt;p32, <span class="hljs-type">int</span>&gt; p;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		cin &gt;&gt; a &gt;&gt; b, h[i] = <span class="hljs-built_in">make_pair</span>(a, b);<br>		cnt1[a]++, cnt2[b]++, p[h[i]]++;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(h + <span class="hljs-number">1</span>, h + n + <span class="hljs-number">1</span>);<br>	mint c0 = fac[n], c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">1</span>, c12 = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (h[i].second &lt; h[i - <span class="hljs-number">1</span>].second) c12 = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : cnt1) c1 *= fac[i.second];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : cnt2) c2 *= fac[i.second];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : p) c12 *= fac[i.second];<br>	cout &lt;&lt; c0 - c1 - c2 + c12;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="P1447-NOI2010-能量采集"><a href="#P1447-NOI2010-能量采集" class="headerlink" title="P1447 [NOI2010] 能量采集"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1447">P1447 [NOI2010] 能量采集</a></h3><p>组合数学的原理也可以解决数论问题。在前面的欧拉函数部分，我们知道这样的问题答案是<br>$$<br>\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{m} (2\times\gcd(i, j)-1)&#x3D;2\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{m} \gcd(i,j)-nm<br>$$<br>可以发现 $\gcd(i,j)$ 的值只有 $n$ 种，不妨考虑 $gcd(i,j)&#x3D;k$ 的数目，设其数目为 $f(k)$。我们可以考虑求以 $k$ 为公约数的数对数目，再减去以 $k$ 的倍数为公约数的数对数目。进一步推导，以 $k$  的倍数为公约数的数对个数等于所有以 $k$ 的倍数为最大公约数的数对个数之和。于是有<br>$$<br>f(k)&#x3D;\lfloor \dfrac{n}{k} \rfloor \times\lfloor \dfrac{m}{k} \rfloor -\sum_{i&#x3D;2}^{ik \le \min(n,m)} f(ik)<br>$$</p>
<p>我们发现 $2k &gt; \min(n,m)$ 时 $f(k)&#x3D;\lfloor \dfrac{n}{k} \rfloor \times\lfloor \dfrac{m}{k} \rfloor$，于是倒着算就行了，是调和型枚举，复杂度 $O(n \log n)$。于是 GCD SUM 问题就多了一种容斥做法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = n; k &gt;= <span class="hljs-number">1</span>; k--) &#123;<br>		f[k] = <span class="hljs-number">1LL</span> * (n / k) * (m / k);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * k &lt;= <span class="hljs-built_in">min</span>(n, m); i++) f[k] -= f[i * k];<br>	&#125;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += f[i] * i;<br>	cout &lt;&lt; res * <span class="hljs-number">2</span> - <span class="hljs-number">1LL</span> * n * m;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AT-abc162-e-ABC162E-Sum-of-gcd-of-Tuples-Hard"><a href="#AT-abc162-e-ABC162E-Sum-of-gcd-of-Tuples-Hard" class="headerlink" title="AT_abc162_e [ABC162E] Sum of gcd of Tuples (Hard)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc162_e">AT_abc162_e [ABC162E] Sum of gcd of Tuples (Hard)</a></h3><p>笔者数论训练赛の T5。和上面题的套路一样，我们发现，$\gcd a_i&#x3D;k$ 时当且仅当 $a_1,a_2, \cdots,a_n$ 均为 $k$ 的倍数，且这个倍数是互质的。考虑容斥 + DP，令 $dp_x$ 表示 $[1,x]$ 内选出 $n$ 个互质数的方法数目。考虑用减法原理，总数目减去不互质的方案，枚举公约数 $i$，则根据约数性质可得<br>$$<br>dp_x&#x3D;x^n-\sum_{i&#x3D;2}^{x} dp_{\lfloor \frac{x}{i} \rfloor}<br>$$<br>赛时写的记搜。可以发现这个东西也是容斥思想。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k;<br>mint dp[N];<br><span class="hljs-function">mint <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (dp[x] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[x]; <br>	<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dp[x] = <span class="hljs-number">1</span>;<br>	mint res = <span class="hljs-built_in">mint</span>(x).<span class="hljs-built_in">pow</span>(n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x; i++) &#123;<br>		res -= <span class="hljs-built_in">solve</span>(x / i); <br>	&#125; <span class="hljs-keyword">return</span> dp[x] = res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) res += <span class="hljs-built_in">solve</span>(k / i) * i;<br>	cout &lt;&lt; res;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="AT-abc366-d-ABC366D-Cuboid-Sum-Query"><a href="#AT-abc366-d-ABC366D-Cuboid-Sum-Query" class="headerlink" title="AT_abc366_d [ABC366D] Cuboid Sum Query"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc366_d">AT_abc366_d [ABC366D] Cuboid Sum Query</a></h3><p>三维前缀和板子题，容斥原理的另一种应用。我们先来推三维前缀和怎么算。设 $pre_{i,j,k}$ 表示以 $(i,j,k)$ 为右下角的立方体数字之和，则它显然由 $a_{i,j,k}$ 贡献。同时考虑去掉一行 &#x2F; 一列 &#x2F; 一柱，加上 $pre_{i-1,j,k}+pre_{i,j-1,k}+pre_{i,j,k-1}$。这样我们会把同时退掉两维的前缀和算重，于是减去 $pre_{i-1,j-1,k}+pre_{i-1,j,k-1}+pre_{i,j-1,k-1}$。这样又把退掉三维的前缀和减多了，所以加上 $pre_{i-1,j-1,k-1}$。总的转移为<br>$$<br>。pre_{i,j,k}&#x3D;a_{i,j,k}+pre_{i-1,j,k}+pre_{i,j-1,k}+pre_{i,j,k-1}-pre_{i-1,j-1,k}-pre_{i-1,j,k-1}-pre_{i,j-1,k-1}+pre_{i-1,j-1,k-1}<br>$$</p>
<p>接着我们考虑单次询问以 $(x_1,y_1,z_1)$ 为左上角，$(x_2,y_2,z_2)$ 为右下角的立方体点权之和。同理可得答案为<br>$$<br>pre_{x_2,y_2,z_2}-pre_{x_1-1,y_2,z_2}-pre_{x_2,y_1-1,z_2}-pre_{x_2,y_2,z_1-1}+pre_{x_1-1,y_1-1,z_2}+pre_{x_1-1,y_2,z_1-1}+pre_{x_2,y_1-1,z_1-1}-pre_{x_1-1,y_1-1,z_1-1}<br>$$<br>于是我们在预处理 $O(n^3)$，查询 $O(1)$ 下解决了该问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n, q, a[N][N][N], pre[N][N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) cin &gt;&gt; a[i][j][k];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>				pre[i][j][k] = a[i][j][k]<br>				+ pre[i][j][k - <span class="hljs-number">1</span>] + pre[i][j - <span class="hljs-number">1</span>][k] + pre[i - <span class="hljs-number">1</span>][j][k]<br>				- pre[i][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>] - pre[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">1</span>] - pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k]<br>				+ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>];<br>			&#125;<br>		&#125;<br>	&#125;<br>	cin &gt;&gt; q;<br>	<span class="hljs-keyword">while</span> (q--) &#123;<br>		<span class="hljs-type">int</span> x1, x2, y1, y2, z1, z2;<br>		cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; z1 &gt;&gt; z2;<br>		cout &lt;&lt; (pre[x2][y2][z2] <br>		- pre[x1 - <span class="hljs-number">1</span>][y2][z2] - pre[x2][y1 - <span class="hljs-number">1</span>][z2] - pre[x2][y2][z1 - <span class="hljs-number">1</span>]<br>		+ pre[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>][z2] + pre[x1 - <span class="hljs-number">1</span>][y2][z1 - <span class="hljs-number">1</span>] + pre[x2][y1 - <span class="hljs-number">1</span>][z1 - <span class="hljs-number">1</span>]<br>		- pre[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>][z1 - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P6651-「SWTR-5」Chain"><a href="#P6651-「SWTR-5」Chain" class="headerlink" title="P6651 「SWTR-5」Chain"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6651">P6651 「SWTR-5」Chain</a></h3><p>一步一步考虑，先想无修改怎么做，我们在拓扑序上做 DP，由加法原理<br>$$<br>f_{i} \gets f_{i}+f_j<br>$$<br>进一步地，由于 $n\le 2\times 10^3$，我们可以利用拓扑排序，在 $O(n^2)$ 时间内预处理从 $u$ 到 $v$ 的链数，则<br>$$<br>dp_{k,v} \gets dp_{k,v}+dp_{k,u}<br>$$<br>类似 Floyd 那样，对于有向边 $(u,v)$，枚举中继点 $k \in [1,n]$，由加法原理合并。记入度为 $ideg_i$，出度为 $odeg_i$，则总链数<br>$$<br>tot&#x3D;\sum_{ideg_i&#x3D;0} \sum_{odeg_j&#x3D;0} dp_{i,j}<br>$$<br>因为一条链的起终点一定满足上述条件。接着我们考虑 $k&#x3D;1$ 的做法，套路地，记 $f_i$ 为链起点到点 $i$ 的方案数，然后建反图，记 $g_i$ 是反图上的 $f_i$，发现 $g_i$ 等价于原图中点 $i$ 到链终点的方案数。由 $dp_{i,j}$ 的定义易得转移：<br>$$<br>f_i &#x3D; \sum_{ideg_j&#x3D;0} dp_{j,i}\<br>g_i &#x3D; \sum_{odeg_j&#x3D;0} dp_{i,j}<br>$$<br> 那么 $k&#x3D;1$ 的情况就可以用 $tot-f_ig_i$ 回答。接着我们想 $k&#x3D;2$，不妨设两点 $u,v$ 中 $u$ 的拓扑序小于 $v$，分类讨论：</p>
<ul>
<li>若 $u,v$ 不在同一条链上，直接用 $tot-f_ug_u-f_vg_v$ 回答；</li>
<li>若 $u,v$ 可以在同一条链上，那么 $u$ 到终端的路径包含了 $v$。考虑容斥把重复的加回来，这里的重复是 $f_ug_v dp_{u,v}$，答案为 $tot-f_ug_u-f_vg_v+f_ug_v dp_{u,v}&#x3D;tot-f_ug_u-g_v(f_v-f_udp_{u,v})$。</li>
</ul>
<p>接着我们扩展到 $k \le 15$。我们先按拓扑序排序，对于每个点处理要容斥掉的数 $h_i$，则<br>$$<br>h_i&#x3D;f_i-\sum h_j dp_{j,i}<br>$$<br>其中 $j$ 的拓扑序在 $i$ 之前。于是答案为<br>$$<br>tot-\sum h_ig_i<br>$$<br>至此，我们在预处理 $O(n^2+m)$，单次查询 $O(k^2)$ 的复杂度下解决了此问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e3</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">2e4</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to;<br>&#125; edge[M];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, head[u] = tot;<br>&#125;<br><span class="hljs-type">int</span> n, m, u, v, q, len, ideg[N], odeg[N];<br><br><span class="hljs-type">int</span> cnt, bfn[N];<br>mint dp[N][N], f[N], g[N], h[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topo</span><span class="hljs-params">()</span> </span>&#123;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (ideg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">emplace</span>(i);<br>		dp[i][i] = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>		bfn[u] = ++cnt;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>			<span class="hljs-type">int</span> v = edge[j].to;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) dp[k][v] += dp[k][u];<br>			<span class="hljs-keyword">if</span> (--ideg[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">emplace</span>(v);<br>		&#125;<br>	&#125;<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; st, ed;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		<span class="hljs-built_in">add_edge</span>(u, v);<br>		odeg[u]++, ideg[v]++;<br>	&#125; <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (ideg[i] == <span class="hljs-number">0</span>) st.<span class="hljs-built_in">emplace_back</span>(i);<br>		<span class="hljs-keyword">if</span> (odeg[i] == <span class="hljs-number">0</span>) ed.<span class="hljs-built_in">emplace_back</span>(i);<br>	&#125; <span class="hljs-built_in">topo</span>();<br>	mint tot = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : st) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : ed) tot += dp[i][j];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : st) f[i] += dp[j][i];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : ed) g[i] += dp[i][j];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (cin &gt;&gt; q; q--; ) &#123;<br>		<span class="hljs-built_in">fill</span>(h, h + len, <span class="hljs-number">0</span>);<br>		cin &gt;&gt; len;<br>		vector&lt;<span class="hljs-type">int</span>&gt; c;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) cin &gt;&gt; u, c.<span class="hljs-built_in">emplace_back</span>(u);<br>		<span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span> &#123;<br>			<span class="hljs-keyword">return</span> bfn[x] &lt; bfn[y];<br>		&#125;);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>			h[i] = f[c[i]];<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) h[i] -= dp[c[j]][c[i]] * h[j];<br>		&#125;<br>		mint res = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) res += h[i] * g[c[i]];<br>		cout &lt;&lt; tot - res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>从 $n$ 个<strong>不同</strong>元素中取 $m$ 个元素排成<strong>有序</strong>的一列，方案数用 $A_{n}^{m}$ 表示。</p>
<p>我们这样计算：第一个数有 $n$ 种选法，第二个数有 $n-1$ 种选法……第 $m$ 个数有 $n-m+1$ 种选法，由乘法原理得</p>
<p>$$<br>A_{n}^{m}&#x3D;n(n-1)(n-2) \cdots (n-m+1)&#x3D;\prod_{i&#x3D;n-m+1}^{n} i&#x3D;\dfrac{n!}{(n-m)!}<br>$$</p>
<p>规定 $m&gt;n$ 时 $A_{n}^{m}&#x3D;0$。</p>
<p>而如果 $m&#x3D;n$，也就是所有元素都参与排列，此时称为全排列。全排列的计算</p>
<p>$$<br>A_{n}^{n}&#x3D;n!<br>$$</p>
<h3 id="全排列的枚举"><a href="#全排列的枚举" class="headerlink" title="全排列的枚举"></a>全排列的枚举</h3><p>在 C++ 标准库中提供了 <code>next_permutation</code> 函数，可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a为要枚举排列的数组，n为长度</span><br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">do</span> &#123;<br>  ...<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure>

<p>时间复杂度为 $O(n!)$。</p>
<h3 id="有重复元素的排列问题"><a href="#有重复元素的排列问题" class="headerlink" title="有重复元素的排列问题"></a>有重复元素的排列问题</h3><p>顾名思义就是元素有重，此时需要除去重复的排列。</p>
<p>考虑一组有 $m$ 个的重复元素，其造成重复的个数就是它在排列中的次序交换，也就是 $m!$ 种情况，所以总排列数</p>
<p>$$<br>\dfrac{n!}{m_1!m_2!m_3! \cdots}<br>$$</p>
<p>其中 $n$ 为总元素个数，$m$ 为各元素出现次数。</p>
<h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><p>从 $n$ 个<strong>不同</strong>元素中取 $m$ 个元素排成<strong>有序</strong>的一圈，方案数用 $Q_{n}^{m}$ 表示。考虑断环为链，共有 $m$ 个断点，故</p>
<p>$$<br>Q_{n}^{m}&#x3D;\dfrac{A_{n}^{m}}{m}&#x3D;\dfrac{n!}{m(n-m)!}<br>$$</p>
<h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><p>康托展开解决的是求排列字典序的问题。先给出公式：<br>$$<br>1+\sum_{i&#x3D;1}^{n} rk_i \times (n-i)!<br>$$<br>其中 $rk_i$ 表示 $[i,n]$ 中有多少个数小于 $a_i$，即 $a_i$ 的后缀排名。理解一下这个公式，字典序就是比当前排列小的排列数目，贪心地枚举 $i$，使得第 $i$ 为小于 $a_i$，而后置位与字典序无关。那么我们就需要把 $i$ 后面小于 $a_i$ 的数换到前面，且根据全排列的原理有 $(n-i)!$ 种方案。</p>
<p>康托展开还有一种进制意义，可以看<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/az9lgvgz"> yummy 大佬的 blog</a>。</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>从 $n$ 个<strong>不同</strong>元素中取 $m$ 个元素组成<strong>无序</strong>的一个集合，方案数用 $C_{n}^{m}$ 表示。</p>
<p>考虑先作排列，由于集合无序，需要除去重复的组合，也就是 $m$ 的全排列，逆用乘法原理：</p>
<p>$$<br>C_{n}^{m}&#x3D;\dfrac{A_{n}^{m}}{m!}&#x3D;\dfrac{n!}{m!(n-m)!}<br>$$</p>
<p>规定 $m&gt;n$ 时 $C_{n}^{m}&#x3D;0$。</p>
<h3 id="组合的枚举"><a href="#组合的枚举" class="headerlink" title="组合的枚举"></a>组合的枚举</h3><p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, cur[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (x &gt; m) <span class="hljs-keyword">return</span> ..., <span class="hljs-built_in">void</span>();  <span class="hljs-comment">// 这里cur就是一个组合，进行处理</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[x - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; i &lt;= n; i++) cur[x] = i, <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>它用于枚举 $1$ 到 $n$ 所有自然数选 $m$ 个的组合。如果套上 <code>next_permutation</code>，还能实现排列的枚举。</p>
<h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>$$<br>(a+b)^n&#x3D;\sum_{i&#x3D;0}^{n} C_{n}^{i} a^{n-i} b^{i}<br>$$</p>
<p>这个定理表明，二项式 $(a+b)^n$ 展开项的系数与组合数有直接关系。</p>
<p>我们知道杨辉三角：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y4q3udx2.png" srcset="/img/loading.gif" lazyload></p>
<p>其每一个位置的数字通过左上 + 右上确定，每一行所对应的就是二项式展开的系数。</p>
<h3 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h3><ol>
<li>对称性：</li>
</ol>
<p>$$<br>C_{n}^{m} &#x3D; C_{n}^{n-m}<br>$$</p>
<p>代数推导易证，组合意义就是把选出的集合取补集。</p>
<ol start="2">
<li>递推式：</li>
</ol>
<p>$$<br>C_{n}^{m}&#x3D;C_{n-1}^{m}+C_{n-1}^{m-1}<br>$$</p>
<p>代数推导略去，组合意义类似 dp 的思想可以证明。这个式子实际上就是杨辉三角的递推式。</p>
<ol start="3">
<li>二项式定理的特殊情况 1：</li>
</ol>
<p>$$<br>2^n&#x3D;\sum_{i&#x3D;0}^{n} C_n^i<br>$$</p>
<p>也就是杨辉三角每一行的和。</p>
<ol start="4">
<li>斐波那契数列：</li>
</ol>
<p>$$<br>fib_{n+1}&#x3D;\sum_{i&#x3D;0}^{n} C_{n-i}^i<br>$$</p>
<p>把杨辉三角每条斜 $30 \degree$ 角的线取出来相加可以发现。</p>
<ol start="5">
<li>范德蒙恒等式：</li>
</ol>
<p>$$<br>C_{m+n}^{k}&#x3D;\sum_{i&#x3D;0}^{k} C_m^i C_n^{k-i}<br>$$</p>
<p>假设有两堆物品，每堆分别有 $m,n$ 个物品，总共取 $k$ 个，则方案数可分解为：从第一堆取 $i$ 个物品，第二堆取 $k-i$ 个物品，且两种选择独立，故由乘法得到贡献。最后方案即为求和。</p>
<ol start="6">
<li>二项式定理的特殊情况 2：</li>
</ol>
<p>$$<br>\sum_{i&#x3D;0}^{n} (-1)^i C_n^i &#x3D; 0<br>$$</p>
<p>特殊情况是 $n&#x3D;0$ 时上式的值为 $1$。</p>
<h3 id="计算组合数"><a href="#计算组合数" class="headerlink" title="计算组合数"></a>计算组合数</h3><h4 id="定义法"><a href="#定义法" class="headerlink" title="定义法"></a>定义法</h4><ul>
<li>优点：写起来简单，不用预处理。</li>
<li>缺点：查询复杂度 $O(m)$。</li>
</ul>
<p>根据定义直接计算，注意先乘后除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		res = res * (n - i + <span class="hljs-number">1</span>) % mod * <span class="hljs-built_in">power</span>(i, mod - <span class="hljs-number">2</span>) % mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h4><ul>
<li>优点：任意模数，写起来简单，查询 $O(1)$。</li>
<li>缺点：预处理时空复杂度均为 $O(n^2)$。</li>
</ul>
<p>即利用组合数性质 2 预处理杨辉三角。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) c[i][j] = c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="逆元法"><a href="#逆元法" class="headerlink" title="逆元法"></a>逆元法</h4><ul>
<li>优点：预处理 $O(n)$，查询 $O(1)$。</li>
<li>缺点：只能在模数为质数时使用。</li>
</ul>
<p>通过预处理阶乘和阶乘的逆元，直接用定义式计算组合数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (a %= mod; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>		a = a * a % mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> fac[N], ifac[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<br>	fac[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">1</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod, ifac[i] = <span class="hljs-built_in">power</span>(fac[i], mod - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Lucas-定理法"><a href="#Lucas-定理法" class="headerlink" title="Lucas 定理法"></a>Lucas 定理法</h4><ul>
<li>优点：预处理 $O(p)$，查询 $O(\log n)$，适用于模数小而 $n,m$ 很大的情况。</li>
<li>缺点：码量稍大，只能处理 $p$ 为质数的情况。</li>
</ul>
<p>Lucas 定理如下：</p>
<p>$$<br>C_n^m \equiv C_{n \bmod p}^{m \bmod p} C_{\lfloor \frac{n}{p}\rfloor}^{\lfloor \frac{m}{p}\rfloor} \pmod p<br>$$</p>
<p>其中 $p$ 是质数。利用这个式子，先用逆元法预处理所有 $p$ 以内的组合数，查询时递归计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (a %= mod; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>		a = a * a % mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> fac[N], ifac[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<br>	fac[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">1</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod, ifac[i] = <span class="hljs-built_in">power</span>(fac[i], mod - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (n &lt; mod &amp;&amp; m &lt; mod) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(n, m);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">lucas</span>(n / mod, m / mod) * <span class="hljs-built_in">C</span>(n % mod, m % mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3807">P3807 【模板】卢卡斯定理&#x2F;Lucas 定理</a>。</p>
<p>Lucas 定理可以实现快速求组合数前缀和，可以看例题中的 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4345">P4345 [SHOI2015] 超能粒子炮·改</a>。</p>
<h4 id="exLucas-法"><a href="#exLucas-法" class="headerlink" title="exLucas 法"></a>exLucas 法</h4><ul>
<li>优点：任意模数，预处理约为 $O(p \log p)$，查询 $O(\log p)$，同样适用于模数小而 $n,m$ 很大的情况。</li>
<li>缺点：码量很大。</li>
</ul>
<p>exLucas 跟 Lucas 没有半毛钱关系。</p>
<p>将模数 $p$ 质因数分解为 $p&#x3D;p_1^{a_1} p_2^{a_2} \cdots$，然后计算 $C_n^m \bmod p^a$，最后再把答案用 exCRT 合并（可见下方数论部分）。</p>
<p>现在的重点是算 $C_n^m \bmod p^a$，由定义式得所求即为 $\dfrac{n!}{m!(n-m)!} \bmod p^a$，只要求出阶乘及逆元即可。先将阶乘中 $p$ 的倍数算掉，即 $\lfloor  \dfrac{n}{p}\rfloor!$，而剩余项存在循环节，可以一起计算，凑不进循环节的单独算。</p>
<p>For example：</p>
<p>$$<br>\begin{aligned}<br>20!&amp;&#x3D;1\times 2\times 3\times 4\times 5\times 6\times 7\times 8\times 9\times 10\times 11\times 12\times 13\times 14\times 15\times 16\times 17\times 18\times 19\times 20\<br>&amp;&#x3D;(1\times 2\times 4\times 5\times 7\times 8\times 10\times 11\times 13\times 14\times 16\times 17\times 19\times 20) \times 6! \times 3^6\<br>&amp;&#x3D;(1\times 2 \times 4 \times 5 \times 7 \times 8)^2\times 19 \times 20 \times 6! \times 3^6<br>\end{aligned}<br>$$</p>
<p>至于阶乘逆元，用 exGCD 求得即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (a %= p; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>		a = a * a % p;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&amp; x, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&amp; y)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>	<span class="hljs-type">int</span> t = x;<br>	x = y, y = t - a / b * y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">inverse</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br>	<span class="hljs-built_in">exgcd</span>(x, p, a, b);<br>	<span class="hljs-keyword">return</span> (a % p + p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> s = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) &#123;<br>		<span class="hljs-keyword">if</span> (i % x) s = s * i % p;<br>	&#125;<br>	s = <span class="hljs-built_in">power</span>(s, n / p, p);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = n / p * p + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (i % x) s = i % p * s % p;<br>	&#125;<br>	<span class="hljs-keyword">return</span> s * <span class="hljs-built_in">calc</span>(n / x, x, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">multilucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = m; i; i /= x) cnt += i / x;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = n; i; i /= x) cnt -= i / x;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = m - n; i; i /= x) cnt -= i / x;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(x, cnt, p) % p * <span class="hljs-built_in">calc</span>(m, x, p) % p * <span class="hljs-built_in">inverse</span>(<span class="hljs-built_in">calc</span>(n, x, p), p) % p<br>		   * <span class="hljs-built_in">inverse</span>(<span class="hljs-built_in">calc</span>(m - n, x, p), p) % p;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">crt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span>* a, <span class="hljs-type">long</span> <span class="hljs-type">long</span>* m)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) mod *= m[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		x[i] = mod / m[i];<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> x0 = <span class="hljs-number">-1</span>, y0 = <span class="hljs-number">-1</span>;<br>		<span class="hljs-built_in">exgcd</span>(x[i], m[i], x0, y0);<br>		res += a[i] * x[i] * (x0 &gt;= <span class="hljs-number">0</span> ? x0 : x0 + m[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> res % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">exlucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> p0[<span class="hljs-number">20</span>], a0[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">2</span>; i * i &lt;= p; i++) &#123;<br>		<span class="hljs-keyword">if</span> (p % i) <span class="hljs-keyword">continue</span>;<br>		p0[++len] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (p % i == <span class="hljs-number">0</span>) p0[len] *= i, p /= i;<br>		a0[len] = <span class="hljs-built_in">multilucas</span>(m, n, i, p0[len]);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">1</span>) p0[++len] = p, a0[len] = <span class="hljs-built_in">multilucas</span>(m, n, p, p);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">crt</span>(len, a0, p0);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4720">P4720 【模板】扩展卢卡斯定理&#x2F;exLucas</a>。</p>
<h2 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a>经典模型</h2><p>这里介绍排列组合题里常用的转化思想，每种模型给出一些例题。</p>
<h3 id="捆绑法"><a href="#捆绑法" class="headerlink" title="捆绑法"></a>捆绑法</h3><p>Q: 有 $n+m$ 个不同元素要进行排列，其中 $m$ 个元素必须连续，求方案数。</p>
<p>A: 将 $m$ 个元素捆绑在一起，内部排列方案为 $m!$ 种，这 $m$ 个元素的整体视为一个元素，则外部排列方案为 $(n+1)!$ 种，由乘法原理得方案数为 $(n+1)!m!$。</p>
<h3 id="插空法"><a href="#插空法" class="headerlink" title="插空法"></a>插空法</h3><p>Q: 有 $n+m$ 个不同元素要进行排列，其中 $m$ 个元素必须两两不相邻，求方案数。</p>
<p>A: 先将 $n$ 个元素全排列，再求 $n+1$ 个空隙而插入 $m$ 块板子的方案数为 $A_{n+1}^{m}$，所以方案数为 $n! A_{n+1}^{m}$。</p>
<h3 id="插板法"><a href="#插板法" class="headerlink" title="插板法"></a>插板法</h3><p>Q1: 现有 $n$ 个相同元素，分为 $k$ 组，每组至少有一个元素，求方案数。<br>（可以抽象为：求方程 $x_1+x_2+\cdots+x_k&#x3D;n$ 的<strong>正</strong>整数解数目）</p>
<p>A1: 不考虑分组，而是考虑间断点，将 $k-1$ 块板子插入到 $n-1$ 个空里，则答案为 $C_{n-1}^{k-1}$。</p>
<p>Q2: 现有 $n$ 个相同元素，分为 $k$ 组，每组可以为空，求方案数。<br>（可以抽象为：求方程 $x_1+x_2+\cdots+x_k&#x3D;n$ 的<strong>非负</strong>整数解数目）</p>
<p>A2: 先借 $k$ 个元素过来放到每组里，由 Q1 可得方案数为 $C_{n+k-1}^{k-1}&#x3D;C_{n+k-1}^{n}$，再把 $k$ 个元素拿走，方案数不变。</p>
<p>Q3: 现有 $n$ 个相同元素，分为 $k$ 组，第 $i$ 组的元素数目不小于 $a_i$，求方案数。<br>（可以抽象为：求方程 $x_1+x_2+\cdots+x_k&#x3D;n$ 的解数目，其中 $x_i \ge a_i$）</p>
<p>A3: 先借 $\sum a_i$ 个元素过来，令 $x_i’&#x3D;x_i-a_i$，可知 $\sum x_i’&#x3D;n-\sum a_i$，由 Q2 得答案为 $C_{n-\sum a_i+k-1}^{n-\sum a_i}$。</p>
<h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><p>如果某些计数问题的限制是“某些物品恰好若干个”，就可以考虑使用二项式反演。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>设 $f_n$ 表示恰好使用 $n$ 个不同元素形成特定结构的方案数，$g_n$ 表示从这 $n$ 个不同元素中选出若干个元素形成特定结构的方案数。</p>
<p>已知 $f_n$ 求 $g_n$ 是简单的，枚举选出多少个元素有<br>$$<br>g_n&#x3D;\sum_{i&#x3D;0}^{n} C_n^i f_i<br>$$<br>反着做却是困难的，这个过程就叫<strong>二项式反演</strong>。有公式：<br>$$<br>f_n&#x3D;\sum_{i&#x3D;0}^{n} C_n^i (-1)^{n-i}g_i<br>$$<br>二项式反演的作用就是把“恰好”转化为“钦定”。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们先给出一个引理<br>$$<br>C_n^r C_r^k&#x3D;C^k_n C^{r-k}_{n-k}<br>$$<br>组合意义和代数推导都易证。</p>
<p>把上述式子展开：<br>$$<br>\begin{aligned}<br>f_n&amp;&#x3D;\sum_{i&#x3D;0}^{n} C_n^i (-1)^{n-i} [\sum_{j&#x3D;0}^{i} C_i^j f_j]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} \sum_{j&#x3D;0}^{i} C_n^i C_i^j (-1)^{n-i} f_j \<br>&amp;&#x3D; \sum_{j&#x3D;0}^{n} \sum_{i&#x3D;j}^{n} C_n^i C_i^j (-1)^{n-i} f_j \<br>&amp;&#x3D; \sum_{j&#x3D;0}^{n} [f_j \times \sum_{i&#x3D;j}^{n} C_n^i C_i^j (-1)^{n-i} ]<br>\end{aligned}<br>$$<br>根据引理可得<br>$$<br>\begin{aligned}<br>f_n&amp;&#x3D;\sum_{j&#x3D;0}^{n} [f_j \times \sum_{i&#x3D;j}^{n} C_n^j C_{n-j}^{i-j} (-1)^{n-i} ]\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{n} [C_n^j f_j \times \sum_{i&#x3D;j}^{n}C_{n-j}^{i-j} (-1)^{n-i} ]\<br>\end{aligned}<br>$$<br>作换元，令 $k&#x3D;i-j$，则 $i&#x3D;k+j$，即有<br>$$<br>\begin{aligned}<br>f_n&amp;&#x3D;\sum_{j&#x3D;0}^{n} [C_n^j f_j \times \sum_{k&#x3D;0}^{n-j}C_{n-j}^{k} (-1)^{n-j-k} ]\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{n} [C_n^j f_j \times \sum_{k&#x3D;0}^{n-j}C_{n-j}^{k} (-1)^{n-j-k}1^k ]<br>\end{aligned}<br>$$<br>由组合数性质 6 可得当且仅当 $n&#x3D;j$ 时 $\sum_{k&#x3D;0}^{n-j}C_{n-j}^{k} (-1)^{n-j-k}1^k$ 为 $1$，故：<br>$$<br>f_n&#x3D;f_n<br>$$<br>由此可以证明二项式反演。</p>
<h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><p>排列组合的题一般有两种，一种是看着就是数学题去推公式，还有一种就是给了你某些操作，你考察操作的一些性质并结合分类讨论抽象一个组合数学的模型，然后解决问题。</p>
<h3 id="P2822-NOIP-2016-提高组-组合数问题"><a href="#P2822-NOIP-2016-提高组-组合数问题" class="headerlink" title="P2822 [NOIP 2016 提高组] 组合数问题"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2822">P2822 [NOIP 2016 提高组] 组合数问题</a></h3><p>我们用二维数组 $c_{i,j}$ 表示 $C_i^j$，然后用二维前缀和预处理 $i \in [0,n], j \in [0, \min(i,m)]$ 中有多少 $k \mid c_{i,j}$，每次 $O(1)$ 查询即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>;<br><span class="hljs-type">int</span> t, k, n, m, c[N][N], pre[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; t &gt;&gt; k;<br>	c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>			c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % k;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N - <span class="hljs-number">1</span>; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>			pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] + pre[i][j - <span class="hljs-number">1</span>] - pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + (c[i][j] == <span class="hljs-number">0</span>);<br>		&#125;<br>		pre[i][i + <span class="hljs-number">1</span>] = pre[i][i];<br>	&#125;<br>	<span class="hljs-keyword">while</span> (t--) &#123;<br>		cin &gt;&gt; n &gt;&gt; m;<br>		<span class="hljs-keyword">if</span> (m &gt; n) m = n;   <span class="hljs-comment">// 注意细节</span><br>		cout &lt;&lt; pre[n][m] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P3223-HNOI2012-排队"><a href="#P3223-HNOI2012-排队" class="headerlink" title="P3223 [HNOI2012] 排队"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3223">P3223 [HNOI2012] 排队</a></h3><p>高中月考题（</p>
<p>考虑减法原理，用女生不相邻的方案数减去女生不相邻而老师相邻的方案数。</p>
<p>求女生不相邻的方案数，用插空法，如果已经排好了 $2$ 个老师和 $n$ 个男生，则会形成 $n+3$ 个空位，在空位上排列 $m$ 个女生即可。由乘法原理，方案数是 $A_{n+2}^{n+2} A_{n+3}^m$。</p>
<p>再考虑求女生不相邻而老师相邻的方案数。用捆绑法，现将老师视为整体，内部方案数为 $A_2^2$；再用插空法，一个老师的整体与 $n$ 个男生形成 $n+1$ 个空位，同理可得方案数为 $A_{n+1}^{n+1}A_{n+2}^{m}$。</p>
<p>综上所述，答案为</p>
<p>$$<br>A_{n+2}^{n+2} A_{n+3}^m-A_2^2A_{n+1}^{n+1}A_{n+2}^{m}<br>$$</p>
<p>注意要用高精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-function">BigInteger <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>	BigInteger res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - m + <span class="hljs-number">1</span>; i &lt;= n; i++) res *= i;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br> 	cout &lt;&lt; <span class="hljs-built_in">A</span>(n + <span class="hljs-number">2</span>, n + <span class="hljs-number">2</span>) * <span class="hljs-built_in">A</span>(m, n + <span class="hljs-number">3</span>) - <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) * <span class="hljs-built_in">A</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">A</span>(m, n + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P11250-GESP202409-八级-手套配对"><a href="#P11250-GESP202409-八级-手套配对" class="headerlink" title="P11250 [GESP202409 八级] 手套配对"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11250">P11250 [GESP202409 八级] 手套配对</a></h3><p>首先先从 $n$ 对手套中拿出 $k$ 对，方案数 $C_n^k$。又因为要恰好拿走 $k$ 对手套，说明剩下的 $m-2k$ 只手套中不能同时选走一对，从其中取出 $m$ 对左或右手套，由乘法原理得答案为 $2^{m-2k} \times C_{n-k}^{m-2k}$，最后再用乘法原理合并答案。预处理组合数用杨辉三角即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>;<br><span class="hljs-type">int</span> n, m, k;<br>modint c[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>	<span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">2</span> * k) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">void</span>();<br>	cout &lt;&lt; c[n][k] * c[n - k][m - <span class="hljs-number">2</span> * k] * <span class="hljs-built_in">modint</span>(<span class="hljs-number">2</span>).<span class="hljs-built_in">pow</span>(m - <span class="hljs-number">2</span> * k) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125; <span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, c[i][i] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) c[i][j] = c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (cin &gt;&gt; t; t--; ) _main();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P5367-【模板】康托展开"><a href="#P5367-【模板】康托展开" class="headerlink" title="P5367 【模板】康托展开"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P5367">P5367 【模板】康托展开</a></h3><p>康托展开板子题，但你要是直接按公式求是 $O(n^2)$ 的。显然枚举 $i$ 不能删，瓶颈在计算 $rk_i$，使用权值树状数组维护即可。</p>
<p>实现时，可以把树状数组上每个位置都加一，然后出现了这个数再减一，这样 $rk_i$ 转化为树状数组前缀求和。复杂度 $O(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-type">int</span> tr[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span> </span>&#123;<span class="hljs-keyword">for</span> (; x &lt;= n; x += (x &amp; -x)) tr[x] += c;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; x != <span class="hljs-number">0</span>; x -= (x &amp; -x)) res += tr[x];<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br>mint fac[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, <span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>	mint res = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初值为1</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += fac[n - i] * (<span class="hljs-built_in">ask</span>(a[i]) - <span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(a[i], <span class="hljs-number">-1</span>);<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P3014-USACO11FEB-Cow-Line-S"><a href="#P3014-USACO11FEB-Cow-Line-S" class="headerlink" title="P3014 [USACO11FEB] Cow Line S"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3014">P3014 [USACO11FEB] Cow Line S</a></h3><p>这题多了一个给定排名求排列的操作，就是把康托展开的过程反过来。具体可见代码，并且这个逆操作也是可以用权值树状数组 &#x2F; 权值线段树维护的，但是这题没有必要。具体过程很类似进制转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, q, a[N], ans[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x, fac[N], w[N];<br><span class="hljs-type">char</span> opt;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tr[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> c)</span> </span>&#123;<span class="hljs-keyword">for</span> (; x &lt;= n; x += (x &amp; -x)) tr[x] += c;&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; x != <span class="hljs-number">0</span>; x -= (x &amp; -x)) res += tr[x];<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> pos = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(n); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>		x += (<span class="hljs-number">1</span> &lt;&lt; i);<br>		<span class="hljs-keyword">if</span> (x &gt;= n || pos + tr[x] &gt;= k) x -= (<span class="hljs-number">1</span> &lt;&lt; i);<br>		<span class="hljs-keyword">else</span> pos += tr[x];<br>	&#125; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; q;<br>	fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i;<br>	<span class="hljs-keyword">while</span> (q--) &#123;<br>		<span class="hljs-built_in">memset</span>(tr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(tr));<br>		cin &gt;&gt; opt;<br>		<span class="hljs-keyword">if</span> (opt == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], <span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>			<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;  <br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += fac[n - i] * (<span class="hljs-built_in">ask</span>(a[i]) - <span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(a[i], <span class="hljs-number">-1</span>);<br>			cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-string">&#x27;P&#x27;</span>) &#123;<br>			cin &gt;&gt; x; x--;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) w[n - i + <span class="hljs-number">1</span>] = x % i, x /= i, <span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans[i] = <span class="hljs-built_in">kth</span>(w[i] + <span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(ans[i], <span class="hljs-number">-1</span>);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>			cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>数据范围更大的逆康托展开模板：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11525">UVA11525</a>。</p>
<h3 id="CF1436C-Binary-Search"><a href="#CF1436C-Binary-Search" class="headerlink" title="CF1436C Binary Search"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1436C">CF1436C Binary Search</a></h3><p>考虑二分查找的过程，由于 $n$ 是固定的，则二分查找的路径是唯一的，因此我们可以求出一定小于等于 $x$ 的数的个数，一定大于 $x$ 的数的个数，分别记作 $a,b$。那么在小于等于 $x$ 的 $x-1$ 个数中，就要找 $a-1$ 个数出来排列（因为还有一个数等于 $x$） ，而大于 $x$ 的 $n-x$ 个数中找 $b$ 个来排列，剩下的任意排列，是全排列。</p>
<p>由乘法原理可得答案<br>$$<br>A_{x-1}^{a-1} A_{n-x}^{b} A_{n-a-b}^{n-a-b}<br>$$<br>计算排列数也可以用逆元法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> n, x, pos;<br>mint fac[N], ifac[N];<br><span class="hljs-function">mint <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[n - m];<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; x &gt;&gt; pos;<br>	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n, a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>		<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (mid &lt;= pos) l = mid + <span class="hljs-number">1</span>, a++;<br>		<span class="hljs-keyword">else</span> r = mid, b++;<br>	&#125; fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	cout &lt;&lt; <span class="hljs-built_in">A</span>(a - <span class="hljs-number">1</span>, x - <span class="hljs-number">1</span>) * <span class="hljs-built_in">A</span>(b, n - x) * <span class="hljs-built_in">A</span>(n - a - b, n - a - b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P9306-「DTOI-5」进行一个排的重-Minimum-Version"><a href="#P9306-「DTOI-5」进行一个排的重-Minimum-Version" class="headerlink" title="P9306 「DTOI-5」进行一个排的重 (Minimum Version)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9306">P9306 「DTOI-5」进行一个排的重 (Minimum Version)</a></h3><p>考虑 $f(a)$ 的计算方法，可以发现就是 $p_i,q_i$ 是否为 $[1,i]$ 的前缀最值。显然，若存在 $i \in [1,n]$ 使得 $p_i&#x3D;q_i&#x3D;n$，直接把这个换到前面去，其他的数任意排列都不会产生贡献，因此答案为 $2$ 和 $(n-1)!$。</p>
<p>通过上述讨论，我们发现 $p_i&#x3D;n$ 和 $q_j&#x3D;n$ 的位置是关键的。若不存在上述 $i$，手玩一下把 $p_i&#x3D;n$ 的一项放到前面去，可以构造答案为 $3$。方案如下：第一项贡献为 $2$，而 $q_j$ 必然产生 $1$ 的贡献，如果不产生其他贡献，就必须在 $q_i$ 前放小于它的数。逆用乘法原理，在 $(n-1)!$ 的原方案中除去 $n-q_i$，故答案为 $\dfrac{(n-1)!}{n-q_i}$。把 $q_j$ 放到前面的方案同理，由加法原理合并答案为<br>$$<br>\dfrac{(n-1)!}{n-q_i}+\dfrac{(n-1)!}{n-p_j}<br>$$<br>代码分类讨论一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, p[N], q[N];<br><span class="hljs-function">mint <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	mint res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x; i++) res *= i;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i];<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>		<span class="hljs-keyword">if</span> (p[x] == n) i = x;<br>		<span class="hljs-keyword">if</span> (q[x] == n) j = x;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (i == j) cout &lt;&lt; <span class="hljs-string">&quot;2 &quot;</span> &lt;&lt; <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;3 &quot;</span> &lt;&lt; <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>) / (n - q[i]) + <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>) / (n - p[j]);<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="CF1696E-Placing-Jinas"><a href="#CF1696E-Placing-Jinas" class="headerlink" title="CF1696E Placing Jinas"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1696E">CF1696E Placing Jinas</a></h3><p>显然是从格子 $(0,0)$ 开始操作，一路递推，故设 $(x,y)$ 的末值为 $f_{x,y}$，则<br>$$<br>f_{x,y}&#x3D;f_{x-1,y}+f_{x,y-1}<br>$$<br>对比杨辉三角的计算方法（组合数性质 2）<br>$$<br>C_{n}^{m}&#x3D;C_{n-1}^{m}+C_{n-1}^{m-1}<br>$$<br>发现两者很像，考虑用组合数表示 $f_{x,y}$。对比两者系数可得<br>$$<br>f_{x,y}&#x3D;C_{x+y}^{x}<br>$$<br>因此答案为<br>$$<br>\sum_{i&#x3D;0}^{n} \sum_{j&#x3D;0}^{a_i-1} f_{i,j}&#x3D;\sum_{i&#x3D;0}^{n} \sum_{j&#x3D;0}^{a_i-1} C^{i}<em>{i+j}<br>$$<br>预处理逆元后复杂度为 $O(nV)$，无法通过。所以得推波式子：<br>$$<br>\begin{aligned}<br>ans&amp;&#x3D;\sum</em>{i&#x3D;0}^{n} \sum_{j&#x3D;0}^{a_i-1} f_{i,j}\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} (f_{i,0}+f_{i,1}+\cdots+f_{i,a_i-1})\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} (f_{i+1,0}+f_{i,1}+\cdots+f_{i,a_i-1})\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} (f_{i+1,1}+f_{i,2}+\cdots+f_{i,a_i-1})\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} (f_{i+1,2}+f_{i,3}+\cdots+f_{i,a_i-1})\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} f_{i+1,a_i-1+1}\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n} C_{i+a_i}^{i+1}<br>\end{aligned}<br>$$<br>在推式子的过程中，利用 $f_{x,y}&#x3D;f_{x-1,y}+f_{x,y-1}$ 不断合并相邻两项即可。还有一种方法是化成组合数求和后裂项。</p>
<p>采用预处理逆元求组合数，复杂度可以做到 $O(n)$。注意 $a_i+i$ 可以到 $4\times 10^{5}$，预处理范围要开大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N];<br>mint fac[N], ifac[N];<br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] * ifac[n - m]; <br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) res += <span class="hljs-built_in">C</span>(i + a[i], i + <span class="hljs-number">1</span>);<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CF571A-Lengthening-Sticks"><a href="#CF571A-Lengthening-Sticks" class="headerlink" title="CF571A Lengthening Sticks"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF571A">CF571A Lengthening Sticks</a></h3><p>考虑求合法数目，发现 $a+b&gt;c$ 性质不太好。正难则反，用减法原理，用总数减去不合法的数目。</p>
<p>先求总数。枚举加上的数总和为 $i \in [1,l]$，加到 $3$ 个数上，用插板法，$k$ 个小球之间插 $2$ 块板，方案数为 $C_{i+2}^2$，且 <code>0, 0, 0</code> 也属于总数，故总数<br>$$<br>1+\sum_{i&#x3D;1}^{l}C_{i+2}^2&#x3D;1+\sum_{i&#x3D;1}^{k}\dfrac{(i+1)(i+2)}{2}<br>$$<br>再考虑不合法的方案。不妨设 $c$ 为最长边，枚举 $i \in [0,l]$ 分配给 $c$，则 $l-i$ 个数分配给 $a,b$，且要求 $a+b \le c$，所以不合法分配为 $u&#x3D;\min(c+i-a-b, l-i)$，方案数为 $C^{2}_{u+2}&#x3D;\dfrac{(u+1)(u+2)}{2}$，加法原理合并方案。然后对于 $a,b$ 为最长边同理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">int</span> a, b, c, l;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= l; i++) &#123;<br>		<span class="hljs-type">int</span> u = <span class="hljs-built_in">min</span>(c + i - a - b, l - i);<br>		<span class="hljs-keyword">if</span> (u &gt;= <span class="hljs-number">0</span>) res += (u + <span class="hljs-number">1</span>) * (u + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; l;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; i++) res += (i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>	res -= <span class="hljs-built_in">solve</span>(a, b, c), res -= <span class="hljs-built_in">solve</span>(a, c, b), res -= <span class="hljs-built_in">solve</span>(b, c, a);<br>	cout &lt;&lt; res;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="CF1929F-Sasha-and-the-Wedding-Binary-Search-Tree"><a href="#CF1929F-Sasha-and-the-Wedding-Binary-Search-Tree" class="headerlink" title="CF1929F Sasha and the Wedding Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1929F">CF1929F Sasha and the Wedding Binary Search Tree</a></h3><p>BST 题经典套路中序遍历，问题转化为给 $-1$ 赋值使序列单调不降的方案数。进一步地，对于两个已经确定的点 $i,j$，则对 $(i,j)$ 中的数产生限制 $num \in [a_i,a_j]$，于是我们只需解决这个问题：</p>
<ul>
<li>给出一个长为 $n$ 的序列，值域为 $[l,r]$，求让其单调不降的方案数。</li>
</ul>
<p>很遗憾的是笔者赛时没有做出来。考虑先把第 $i$ 个数加上 $i$，则单调不降转为严格递增。而递增序列直接选出 $n$ 个不同的数即可，值域为 $[l+1,r+n]$，故答案就是 $C_{r-l+n}^{n}$。或者考虑插板法，$n$ 块板子插入 $r-l+n$ 个空也能得出来。</p>
<p>注意 $c$ 很大，直接逆元法会 RE，但 $\sum n \le 10^6$，所以分子可以暴力，仍然处理一下逆元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">5</span>;<br>mint fac[N], ifac[N];<br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;  <br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//return fac[n] * ifac[m] * ifac[n - m]; </span><br>	mint res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - m + <span class="hljs-number">1</span>; i &lt;= n; i++) res *= i;<br>	<span class="hljs-keyword">return</span> res * ifac[m];<br>&#125; <span class="hljs-function">mint <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span> || l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(r - l + n, n);<br>&#125;<br><br><span class="hljs-type">int</span> n, c, a[N], ls[N], rs[N], v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (rt == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">dfs</span>(ls[rt]), a[++a[<span class="hljs-number">0</span>]] = v[rt], <span class="hljs-built_in">dfs</span>(rs[rt]);<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; c;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; ls[i] &gt;&gt; rs[i] &gt;&gt; v[i];<br>	a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>	mint res = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>		res *= <span class="hljs-built_in">solve</span>(i - l - <span class="hljs-number">1</span>, l ? a[l] : <span class="hljs-number">1</span>, a[i]);<br>		l = i;<br>	&#125;<br>	res *= <span class="hljs-built_in">solve</span>(n - l, l ? a[l] : <span class="hljs-number">1</span>, c);<br>	cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CF1227F2-Wrong-Answer-on-test-233-Hard-Version"><a href="#CF1227F2-Wrong-Answer-on-test-233-Hard-Version" class="headerlink" title="CF1227F2 Wrong Answer on test 233 (Hard Version)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1227F2">CF1227F2 Wrong Answer on test 233 (Hard Version)</a></h3><p>妙妙套路题。考虑单个位置的贡献变化，有 $0$ 变 $1$，$1$ 变 $0$，$0$ 变 $0$，$1$ 变 $1$ 四种情况。由于题目要求 $s’&gt;s$ 的方案数，就只需考虑 $0$ 变 $1$，$1$ 变 $0$ 的情况。而产生变化当且仅当 $h_i$ 与 $h_{i\bmod n+1}$ 不同。若原来的 $a_i&#x3D;h_i$，移动后就不满足 $a’<em>{j}&#x3D;h</em>{j}$，是 $1$ 变 $0$，而若 $a_i&#x3D;h_j$，就是 $0$ 变 $1$。通过上述讨论发现：**$0$ 变 $1$ 的方案数等于 $1$ 变 $0$ 的方案数。**</p>
<p>因此，答案其实就是<br>$$<br>\dfrac{k^n-p}{2}<br>$$<br>其中 $p$ 表示分数不变的方案数。现在我们只要算出 $p$ 即可。设有 $m$ 个位置使得 $h_i$ 与 $h_{i\bmod n+1}$ 不同，分数不变就是说移动时对了 $i$ 个，错了 $i$ 个，则 $2i \le m$，即 $i \in [0,\lfloor \dfrac{m}{2} \rfloor]$。枚举 $i$，考察 $i$ 产生的贡献，有三部分：</p>
<ul>
<li>对了 $i$ 个，从 $m$ 个位置选出 $i$ 个，方案数 $C^i_m$；</li>
<li>错了 $i$ 个，从剩下 $m-i$ 个位置再选 $i$ 个，然后考虑不同选项，一共是错 $m-2i$ 个，且去掉正确的选项与自身，总方案是 $C^{i}_{m-i} (k-2)^{m-2i}$。</li>
<li>除这 $m$ 个以外，其他的可以任意选，方案数 $k^{n-m}$。</li>
</ul>
<p>由乘法原理合并答案<br>$$<br>p&#x3D;\sum_{i&#x3D;0}^{\lfloor \frac{m}{2} \rfloor}C^i_mC^{i}_{m-i} (k-2)^{m-2i}k^{n-m}<br>$$<br>注意特判 $k&#x3D;1$。用逆元法求组合数即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, k, a[N];<br>mint fac[N], ifac[N];<br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] * ifac[n - m]; <br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	<span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (a[i] != a[i % n + <span class="hljs-number">1</span>]) m++;<br>	&#125; mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m / <span class="hljs-number">2</span>; i++) res += <span class="hljs-built_in">C</span>(m, i) * <span class="hljs-built_in">C</span>(m - i, i) * <span class="hljs-built_in">mint</span>(k - <span class="hljs-number">2</span>).<span class="hljs-built_in">pow</span>(m - <span class="hljs-number">2</span> * i) * <span class="hljs-built_in">mint</span>(k).<span class="hljs-built_in">pow</span>(n - m);<br>	cout &lt;&lt; (<span class="hljs-built_in">mint</span>(k).<span class="hljs-built_in">pow</span>(n) - res) / <span class="hljs-number">2</span>;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="CF785D-Anton-and-School-2"><a href="#CF785D-Anton-and-School-2" class="headerlink" title="CF785D Anton and School - 2"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/CF785D">CF785D Anton and School - 2</a></h3><p>考虑枚举子序列的最后一个左括号，可以动态统计其左侧及自身的左括号数目 $a$，右括号数目 $b$，然后枚举再选 $i$ 个括号，则其贡献为<br>$$<br>\sum_{i&#x3D;0}^{\min(a-1,b-1)} C_{a-1}^iC_{b}^{i+1}<br>$$<br>因为括号要匹配，只能枚举到 $\min(a-1,b-1)$，然后考虑组合意义，乘法原理合并两种方案。预处理逆元后复杂度是 $O(n^2)$，无法通过。</p>
<p>根据组合数性质 1，即对称性有<br>$$<br>\sum_{i&#x3D;0}^{\min(a-1,b-1)} C_{a-1}^iC_{b}^{i+1}&#x3D;\sum_{i&#x3D;0}^{\min(a-1,b-1)} C_{a-1}^{a-1-i}C_{b}^{i+1}<br>$$<br>然后应用组合数性质 5，即范德蒙恒等式化简<br>$$<br>\sum_{i&#x3D;0}^{\min(a-1,b-1)} C_{a-1}^{a-1-i}C_{b}^{i+1}&#x3D;C_{a+b-1}^a<br>$$<br>于是逆元法求组合数，复杂度可以为 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N], b[N];<br><span class="hljs-type">char</span> s[N];<br>mint fac[N], ifac[N];<br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] * ifac[n - m]; <br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; (s + <span class="hljs-number">1</span>); n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>	fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = a[i - <span class="hljs-number">1</span>] + (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) b[i] = b[i + <span class="hljs-number">1</span>] + (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>);<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) res += <span class="hljs-built_in">C</span>(a[i] + b[i] - <span class="hljs-number">1</span>, a[i]);<br>	&#125; cout &lt;&lt; res;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="P4859-已经没有什么好害怕的了"><a href="#P4859-已经没有什么好害怕的了" class="headerlink" title="P4859 已经没有什么好害怕的了"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4859">P4859 已经没有什么好害怕的了</a></h3><p>形式化题意：给出长为 $n$ 的序列 $a,b$，将其两两配对使得 $a_i&gt;b_i$ 的数目减去 $a_i&lt;b_i$ 的数目恰为 $k$，求方案数。</p>
<p>设 $a_i&gt;b_i$ 的数量为 $m$，则 $m-(n-m)&#x3D;k$，解得 $m&#x3D;\dfrac{n+k}{2}$。若 $2 \nmid (n+k)$，直接判定无解。此时问题变成 $a_i&gt;b_i$ 的数目<strong>恰好</strong>为 $m$。考虑使用二项式反演化恰好为钦定。设 $g_i$ 为 $a_i&gt;b_i$ 的组数不小于 $i$ 的方案数，根据二项式反演所求为<br>$$<br>\sum_{i&#x3D;m}^{n} (-1)^{i-m} C_{i}^k g_i<br>$$<br>现在的问题就是求 $g_i$，这玩意很 DP，所以设 $dp_{i,j}$ 表示前 $i$ 个数中选出 $j$ 组 $a_i&gt;b_i$ 的方案数。DP 题套路对 $a,b$ 排序，然后可以推出转移方程<br>$$<br>dp_{i,j}&#x3D;dp_{i-1,j}+(last_i-j+1)dp_{i-1,j-1}<br>$$<br>可以看看下文的排列计数 DP，从插入角度考虑 $(a_i,b_i)$ 的贡献，一种情况是不作为新的 $a_i&gt;b_i$，还有一种就是考虑有多少个取代位置。设 $last_i$ 表示 $b$ 序列中第一个小于 $a_i$ 的数的下标，则插入位置就有 $last_i-j+1$ 个，加法原理合并答案。</p>
<p>于是我们 $O(n^2)$ 求出 $dp_{i,j}$。考察 $g_i$ 的定义可得<br>$$<br>g_i&#x3D;dp_{n,i}\times  (n-i)!<br>$$<br>就是在有序的 dp 基础上考虑剩下 $n-i$ 个全排列。</p>
<p>二项式反演中组合数可以逆元法来求，总复杂度 $O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>;<br><span class="hljs-type">int</span> n, m, k, a[N], b[N], last[N];<br>mint fac[N], ifac[N], dp[N][N], g[N];<br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] * ifac[n - m]; <br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-keyword">if</span> ((n + k) &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>	fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	<br>	m = (n + k) / <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i];<br>	<span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>), <span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + n + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) last[i] = <span class="hljs-built_in">lower_bound</span>(b + <span class="hljs-number">1</span>, b + n + <span class="hljs-number">1</span>, a[i]) - b - <span class="hljs-number">1</span>;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>			dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, last[i] - j + <span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) g[i] = dp[n][i] * fac[n - i];<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> ((i - m) &amp; <span class="hljs-number">1</span>) res -= <span class="hljs-built_in">C</span>(i, m) * g[i];<br>		<span class="hljs-keyword">else</span> res += <span class="hljs-built_in">C</span>(i, m) * g[i];<br>	&#125; cout &lt;&lt; res;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="P4345-SHOI2015-超能粒子炮·改"><a href="#P4345-SHOI2015-超能粒子炮·改" class="headerlink" title="P4345 [SHOI2015] 超能粒子炮·改"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4345">P4345 [SHOI2015] 超能粒子炮·改</a></h3><p>组合数前缀和科技的板子。题意还是比较清楚的，就是求<br>$$<br>f(n,k)&#x3D;\sum_{i&#x3D;0}^{k} C_n^i \bmod 2333<br>$$<br>打个试除法判质数可以发现 $2333$ 是质数，于是这个题适用 Lucas 定理，下面设 $p&#x3D;2333$，那么<br>$$<br>f(n,k)&#x3D;\sum_{i&#x3D;0}^{k} C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{i}{p} \rfloor} C_{n \bmod p}^{i \bmod p}<br>$$<br>接着我们把后面的 $C_{n \bmod p}^{i \bmod p}$ 按取模意义考虑贡献，且对于 $\lfloor \dfrac{i}{p} \rfloor$ 进行讨论，则<br>$$<br>\begin{aligned}<br>f(n,k)&amp;&#x3D;C_{\lfloor \frac{n}{p} \rfloor}^0 \sum_{i&#x3D;0}^{p-1} C_{n \bmod p}^i+C_{\lfloor \frac{n}{p} \rfloor}^1 \sum_{i&#x3D;0}^{p-1} C_{n \bmod p}^i+\cdots+C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p}-1 \rfloor} \sum_{i&#x3D;0}^{p-1} C_{n \bmod p}^i+C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p} \rfloor} \sum_{i&#x3D;0}^{k \bmod p} C_{n \bmod p}^i\<br>&amp;&#x3D;(\sum_{i&#x3D;0}^{p-1} C_{n \bmod p}^i)(C_{\lfloor \frac{n}{p} \rfloor}^0+C_{\lfloor \frac{n}{p} \rfloor}^1 +\cdots+C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p}-1 \rfloor} )+C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p} \rfloor} \sum_{i&#x3D;0}^{k \bmod p} C_{n \bmod p}^i\<br>&amp;&#x3D;f(n \bmod p,p-1) \times f(\lfloor \dfrac{n}{p} \rfloor, \lfloor \dfrac{k}{p}-1 \rfloor)+C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p} \rfloor} \times f(n \bmod p,k \bmod p)<br>\end{aligned}<br>$$<br>对于前面的 $n \bmod p$，根据余数性质可得这个东西小于 $p$，所以我们可以直接 $O(p^2)$ 地递推法求出。对于 $\dfrac{n}{p}$，$n$ 每次至少除掉 $p$，复杂度级别为 $O(\log n)$。最后的 $C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{k}{p} \rfloor}$ 可以用 Lucas 定理法求出。预处理 $O(p^2)$，单次查询 $O(\log (n+k))$，但由于这个对数的底数为 $p&#x3D;2333$，可以直接当作小常数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2400</span>, p = <span class="hljs-number">2333</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> q, n, k;<br>mint c[N][N], pre[N][N];<br><br><span class="hljs-function">mint <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (n == m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> c[n % p][m % p] * <span class="hljs-built_in">lucas</span>(n / p, m / p);<br>&#125;<br><span class="hljs-function">mint <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (n &lt; p &amp;&amp; k &lt; p) <span class="hljs-keyword">return</span> pre[n][k];<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n / p, k / p - <span class="hljs-number">1</span>) * pre[n % p][p - <span class="hljs-number">1</span>] + pre[n % p][k % p] * <span class="hljs-built_in">lucas</span>(n / p, k / p);<br>&#125; <br><br><span class="hljs-type">void</span> _main() &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, c[i][i] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) c[i][j] = c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>		pre[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) pre[i][j] = pre[i][j - <span class="hljs-number">1</span>] + c[i][j];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (cin &gt;&gt; q; q--; ) cin &gt;&gt; n &gt;&gt; k, cout &lt;&lt; <span class="hljs-built_in">f</span>(n, k) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="错位排列"><a href="#错位排列" class="headerlink" title="错位排列"></a>错位排列</h1><p>错排数 $D_i$ 是指将 $1$ 到 $n$ 的自然数排列重新排列为 $P_i$ 后，满足 $\forall i \in [1,n], P_i \ne i$ 的方案数。</p>
<p>例如，$n&#x3D;3$ 时，错位排列有 ${2,3,1}$ 和 ${3,1,2}$。</p>
<h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><p>计算错排数可以递推。考虑 $D_n$ 时，先把 $n$ 放在 $P_n$，然后有两种情况：</p>
<ol>
<li>前面 $n-1$ 个数已经是错位排列；</li>
<li>前面 $n-1$ 个数有一个在原位上，其他错位。</li>
</ol>
<p>对于情况 1，第 $n$ 个数可以与任一数字交换，有 $(n-1)D_{n-1}$ 种方案；</p>
<p>对于情况 2，第 $n$ 个数只能与原位上的交换，有 $(n-1)D_{n-2}$ 种方案；</p>
<p>因此，</p>
<p>$$<br>D_n&#x3D;(n-1)(D_{n-1}+D_{n - 2})<br>$$</p>
<p>另外地，$D_1&#x3D;0,D_2&#x3D;1$。</p>
<p>对 $D_n&#x3D;(n-1)(D_{n-1}+D_{n - 2})$ 变形：<br>$$<br>\begin{aligned}<br>D_n&amp;&#x3D;(n-1)(D_{n-1}+D_{n - 2})\<br>D_n&amp;&#x3D;(n-1)D_{n-1}+(n-1)D_{n-2}\<br>D_n-nD_{n-1}&amp;&#x3D;-D_{n-1}+(n-1)D_{n-2}\<br>D_n-nD_{n-1}&amp;&#x3D;(-1)(D_{n-1}-(n-1)D_{n-2})<br>\end{aligned}<br>$$<br>由此可见 $D_n-nD_{n-1}$ 是首项为 $1$，公比为 $-1$ 的等差数列，由此可得错排的另一个递推式<br>$$<br>D_n&#x3D;nD_{n-1}+(-1)^n<br>$$</p>
<h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><p>由递推式 2，两边同时除以 $n!$ 有<br>$$<br>\dfrac{D_n}{n!}&#x3D;\dfrac{D_{n-1}}{(n-1)!}+\dfrac{(-1)^n}{n!}<br>$$<br>根据递推式不断代入，累加：<br>$$<br>\dfrac{D_n}{n!}&#x3D;\sum_{k&#x3D;0}^{n} \dfrac{(-1)^k}{k!}<br>$$<br>因此可得错排通项公式<br>$$<br>D_n&#x3D;n!\sum_{k&#x3D;0}^{n} \dfrac{(-1)^k}{k!}<br>$$</p>
<h3 id="范围估计"><a href="#范围估计" class="headerlink" title="范围估计"></a>范围估计</h3><p>根据通项公式可以估计错排的增长速度。由式子<br>$$<br>\dfrac{D_n}{n!}&#x3D;\sum_{k&#x3D;0}^{n} \dfrac{(-1)^k}{k!}<br>$$<br>可以想到 $e^{-1}$ 的泰勒展开。通过配凑可写出 $\dfrac{1}{e}$ 在 $x&#x3D;-1$ 处的泰勒展开：<br>$$<br>\dfrac{1}{e}&#x3D;\sum_{k&#x3D;0}^{\infty} \dfrac{(-1)^k}{k!}<br>$$<br>因此：<br>$$<br>\dfrac{1}{e}&#x3D;\dfrac{D_n}{n!} + \sum_{k&#x3D;n+1}^{\infty} \dfrac{(-1)^k}{k!}<br>$$<br>注意到，当 $n$ 增加时，后面的和式趋近于 $0$，因此可得错排数列的极限：<br>$$<br>\lim_{n \to +\infty} D_n&#x3D;\dfrac{n!}{e}<br>$$<br>即 $D_n&#x3D;O(n!)$。因此在复杂度中用到错排时，可认为它是阶乘级别的。</p>
<h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><h3 id="P1595-信封问题"><a href="#P1595-信封问题" class="headerlink" title="P1595 信封问题"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1595">P1595 信封问题</a></h3><p>板子题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> d[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	d[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; N; i++) d[i] = (i - <span class="hljs-number">1</span>) * (d[i - <span class="hljs-number">1</span>] + d[i - <span class="hljs-number">2</span>]);<br>	cin &gt;&gt; n;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4071-SDOI2016-排列计数"><a href="#P4071-SDOI2016-排列计数" class="headerlink" title="P4071 [SDOI2016] 排列计数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4071">P4071 [SDOI2016] 排列计数</a></h3><p>稍微思考一下就能发现，可以先选出 $m$ 个数，使得 $a_i&#x3D;i$，然后再让剩下 $n-m$ 个数都满足 $a_i \ne i$，这就是错排数 $D_{n-m}$。因此答案即为 $C_{n}^{m} \times D_{n-m}$。采用预处理逆元的方法求组合数即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> d[N], fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (a %= mod; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>		a = a * a % mod;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> t, n, m;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	d[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; N; i++) d[i] = <span class="hljs-number">1LL</span> * (i - <span class="hljs-number">1</span>) * ((d[i - <span class="hljs-number">1</span>] + d[i - <span class="hljs-number">2</span>]) % mod) % mod;<br>	<br>	fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>		fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod;<br>		ifac[i] = <span class="hljs-built_in">power</span>(fac[i], mod - <span class="hljs-number">2</span>);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (cin &gt;&gt; t; t--; ) &#123;<br>		cin &gt;&gt; n &gt;&gt; m;<br>		<span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; d[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">continue</span>;&#125;<br>		<span class="hljs-keyword">if</span> (n == m) &#123;cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">continue</span>;&#125;<br>		<span class="hljs-keyword">if</span> (n == m + <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">continue</span>;&#125;<br>		cout &lt;&lt; (fac[n] * ifac[m] % mod * ifac[n - m] % mod) * (n &gt;= m ? d[n - m] : <span class="hljs-number">1</span>) % mod &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的思想可以解决 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8788">P8788</a> 的问题 A。</p>
<h1 id="Catalan-数"><a href="#Catalan-数" class="headerlink" title="Catalan 数"></a>Catalan 数</h1><p>Catalan 数的起源是凸多边形三角剖分问题，即对于一个凸 $n$ 边形，有多少种方式可以用不相交的对角线将其划分为若干个三角形。这里将方案数记作 $H_n$。Catalan 数列为：<br>$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\cdots$</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol>
<li>括号序列计数</li>
</ol>
<p>Q: 计算 $n$ 对括号能形成多少种合法括号序列。</p>
<p>A: 方案数为 $H_n$。因为序列的第一个括号必须为 <code>(</code>，设之后有一个长度为 $m$ 的子序列，然后为 <code>)</code>，再然后是另一个子序列，长度为 $n-m-1$，则方案为 $H_n&#x3D;\sum_{m&#x3D;0}^{n-1} H_i H_{n-m-1}$，这就是 Catalan 的递推式。</p>
<ol start="2">
<li>不同构二叉树计数</li>
</ol>
<p>Q: 计算 $n$ 个节点的不同构二叉树数目。</p>
<p>A: 数目为 $H_n$。设根节点左子树大小为 $m$，则右子树大小为 $n-m-1$，左右子树又是一个子问题，所以方案为 $H_n&#x3D;\sum_{m&#x3D;0}^{n-1} H_i H_{n-m-1}$，符合递推式。</p>
<ol start="3">
<li>三角剖分问题</li>
</ol>
<p>Q: 求对于一个凸 $n$ 边形，有多少种方式可以用不相交的对角线将其划分为若干个三角形。</p>
<p>A: 方案数为 $H_n$。固定多边形的一条边并选择一个与它不共线的初始顶点构成一个三角形，这个三角形将原多边形分为两个小多边形，大小分别为 $m$ 和 $n-m-1$，所以方案还是那个 $H_n&#x3D;\sum_{m&#x3D;0}^{n-1} H_i H_{n-m-1}$。</p>
<ol start="4">
<li>不越过对角线的网格路径</li>
</ol>
<p>Q: 在 $n \times n$ 网格中，从 $(0,0)$ 走到 $(n,n)$ 且只能向右或向上移动，求不越过对角线 $y&#x3D;x$ 的路径数，如图所示。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0ztrlo61.png" srcset="/img/loading.gif" lazyload></p>
<p>A: 路径数为 $H_n$。如果你不考虑限制，就是在总共 $2n$ 步中分出 $n$ 步走上或者右，总之方案数为 $C_{2n}^{n}$。用减法原理，算不合法的方案，则不合法路径的终点是 $(n-1,n+1)$，选出 $n-1$ 步走右，方案数 $C_{2n}^{n-1}$，因此答案为 $C_{2n}^n-C_{2n}^{n-1}$。这是 Catalan 数的通项公式。</p>
<ol start="5">
<li>出栈序列计数</li>
</ol>
<p>Q: 入栈序列为一个 $1$ 到 $n$ 的排列，求合法出栈序列数目。</p>
<p>A: 数目为 $H_n$。设第一个入栈元素在第 $m$ 个出栈，则前面 $m-1$ 个必须在之前出入栈，而之后又 $n-m-1$ 种，递推式又双叒叕是 $H_n&#x3D;\sum_{m&#x3D;0}^{n-1} H_i H_{n-m-1}$。</p>
<p>由此可见，能用 Catalan 数解决的问题都满足一个递归分解结构：<strong>一个大小为 $n$ 的问题可以分解为两个独立子问题，规模分别为 $m$ 与 $n-m-1$，且两子问题分步</strong>，也就是用乘法原理组合。</p>
<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>上面已经给出了一个递推式：</p>
<p>$$<br>H_n&#x3D;\sum_{i&#x3D;0}^{n-1} H_{i-1} H_{n-i}<br>$$</p>
<p>还有一个递推式：</p>
<p>$$<br>H_n&#x3D;\dfrac{H_{n-1}(4n-2)}{n+1}<br>$$</p>
<p>根据问题 4 可知通项公式：</p>
<p>$$<br>H_n&#x3D;\dfrac{C_{2n}^n}{n+1}&#x3D;C_{2n}^n-C_{2n}^{n-1}<br>$$</p>
<p>使用递推式可以在 $O(n)$ 复杂度内预处理 $H_i$。而使用通项公式再用 lucas &#x2F; exLucas 等科技则可以获得更低的复杂度。</p>
<h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><h3 id="P1044-NOIP-2003-普及组-栈"><a href="#P1044-NOIP-2003-普及组-栈" class="headerlink" title="P1044 [NOIP 2003 普及组] 栈"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1044">P1044 [NOIP 2003 普及组] 栈</a></h3><p>就是问题 5。用递推式 2 计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, h[<span class="hljs-number">20</span>];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	h[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) h[i] = h[i - <span class="hljs-number">1</span>] * (<span class="hljs-number">4</span> * i - <span class="hljs-number">2</span>) / (i + <span class="hljs-number">1</span>);<br>	cout &lt;&lt; h[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P1375-小猫"><a href="#P1375-小猫" class="headerlink" title="P1375 小猫"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1375">P1375 小猫</a></h3><p>题目描述有点抽象，其实就是一个多边形三角剖分问题，所以方案数还是 Catalan 数。代码和上题的区别就是加个取模。</p>
<p>双倍经验：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1976">P1976</a>。</p>
<h3 id="P10413-蓝桥杯-2023-国-A-圆上的连线"><a href="#P10413-蓝桥杯-2023-国-A-圆上的连线" class="headerlink" title="P10413 [蓝桥杯 2023 国 A] 圆上的连线"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10413">P10413 [蓝桥杯 2023 国 A] 圆上的连线</a></h3><p>这题可以不连线，所以先从 $2023$ 个点选 $n$ 个设为必须连边，这一步方案为 $C_{2023}^n$。</p>
<p>然后这个问题就是上一题，答案为 $H_{n&#x2F;2}$。由乘法原理可得答案，注意 $n$ 是偶数。<br>$$<br>\sum_{n&#x3D;0}^{2023} C_{2023}^{n} H_{n&#x2F;2}, n \in {2x | x \in \mathbb{\N^+} }<br>$$<br>考虑到 $2023$ 不是质数，你应该对组合数和 Catalan 数都用递推来求解。答案是 $104$。</p>
<h3 id="P1754-球迷购票问题"><a href="#P1754-球迷购票问题" class="headerlink" title="P1754 球迷购票问题"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1754">P1754 球迷购票问题</a></h3><p>先审题，当 A 买票后，售票处得到一个 $50$ 元；当 B 买票后，售票处失去一个 $50$ 元，所以 A, B 是一个二元对应关系。建立括号模型，将 A 当作左括号，B 当作右括号，发现合法的排队序列就是括号匹配序列，这是问题 1，还是写 Catalan 数即可。</p>
<h3 id="P2532-AHOI2012-树屋阶梯"><a href="#P2532-AHOI2012-树屋阶梯" class="headerlink" title="P2532 [AHOI2012] 树屋阶梯"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2532">P2532 [AHOI2012] 树屋阶梯</a></h3><p><del>把这题放 Catalan 数例题说明了一切。</del></p>
<p>用 $f_i$ 表示高度为 $i$ 的阶梯的搭建方案数，显然 $f_0&#x3D;f_1&#x3D;1$。借用一下第一篇题解的图：</p>
<p><img src="https://i.loli.net/2020/02/02/2xksBinHCIXUWrg.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>枚举每个顶到拐角的矩形，比如这里的第一个矩形，那么右侧方案是 $f_4$。</p>
<p><img src="https://i.loli.net/2020/02/02/RJmZdy1kc5qTEbF.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>再看这个矩形，上侧为 $f_1$，右侧为 $f_3$。</p>
<p><img src="https://i.loli.net/2020/02/02/KXQ4GyxiBv1cOwz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>类似地，上侧为 $f_2$，右侧为 $f_2$。同理可得另外的情况，因此<br>$$<br>f_n&#x3D;\sum_{i&#x3D;0}^{n-1} f_{i} f_{n-i-1}<br>$$<br>这满足“一个大小为 $n$ 的问题可以分解为两个独立子问题，规模分别为 $m$ 与 $n-m-1$，且两子问题分步”的条件，所以所求就是 Catalan 数。然后你整个高精度即可，代码不放了。</p>
<h3 id="P3978-TJOI2015-概率论"><a href="#P3978-TJOI2015-概率论" class="headerlink" title="P3978 [TJOI2015] 概率论"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3978">P3978 [TJOI2015] 概率论</a></h3><p>首先由问题 2 可得不同构二叉树有 $H_n$ 棵。然后设 $f_n$ 表示所有二叉树的叶子节点数目之和。</p>
<p><del>注意到，</del>$f_n&#x3D;nH_{n-1}$。</p>
<p>简证：对于一棵 $n$ 个节点的二叉树，若存在 $k$ 个叶子节点，将 $k$ 个叶子依次删去，可构造得 $k$ 棵 $n-1$ 个点的二叉树，并且这些二叉树还有 $n$ 个点可以挂叶子，因此 $f_n &#x3D;\sum k H_{n-1}&#x3D;nH_{n-1}$。</p>
<p>然后期望为 $E(X)&#x3D;\dfrac{f_n}{H_n}$，代入通项公式 $H_n&#x3D;\dfrac{C_{2n}^n}{n+1}$ 消去可得 $E(X)&#x3D;\dfrac{n(n+1)}{2(2n-1)}$。于是这道紫题就做完了。</p>
<h3 id="P7118-Galgame"><a href="#P7118-Galgame" class="headerlink" title="P7118 Galgame"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7118">P7118 Galgame</a></h3><p>根据问题 2，节点数小于 $n$ 的二叉树数目为<br>$$<br>\sum_{i&#x3D;1}^{n-1} H_i<br>$$<br>重点是算节点数相同的二叉树。根据先左再右的比较方式，设左儿子大小为 $s$，左右儿子总大小为 $n$，和问题 2 相同的推导方法可得方案数是<br>$$<br>\sum_{i&#x3D;0}^{s-1} H_{i} H_{n-i-1}<br>$$<br>预处理 Catalan 数，在 dfs 过程中记录乘子，如果走了左链，右子树就不用管了可以任意选，因此由乘法原理将乘子乘上右子树大小，具体细节看代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, ls[N], rs[N], sz[N];<br>mint h[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!u) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">dfs1</span>(ls[u]), <span class="hljs-built_in">dfs1</span>(rs[u]), sz[u] = sz[ls[u]] + sz[rs[u]] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-function">mint <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, mint x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!u) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz[ls[u]]; i++) res += x * h[i] * h[sz[u] - i - <span class="hljs-number">1</span>];<br>	res += <span class="hljs-built_in">dfs2</span>(ls[u], x * h[sz[rs[u]]]);<br>	res += <span class="hljs-built_in">dfs2</span>(rs[u], x);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; ls[i] &gt;&gt; rs[i];<br>	h[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= (n &lt;&lt; <span class="hljs-number">1</span>); i++) h[i] = h[i - <span class="hljs-number">1</span>] * (<span class="hljs-number">4</span> * i - <span class="hljs-number">2</span>) / (i + <span class="hljs-number">1</span>);<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) res += h[i];<br>	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>), res += <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>	cout &lt;&lt; res;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>喜提 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/227987799">30pts</a> 大黑大紫。因为这样做是 $O(n^2)$ 的，会被左偏形态的树卡满。</p>
<p>考虑当左子树大小大于右子树时，用右子树大小代替左子树大小计算。用减法原理，用总方案数减去不小于原树的二叉树。记右子树大小为 $s$，同理可得答案<br>$$<br>H_n-\sum_{i&#x3D;0}^{s} H_{i}H_{n-i-1}<br>$$<br>然后你神奇地发现这变成了启发式合并，复杂度是 $O(n \log n)$ 的。然后你把 <code>dfs2</code> 改成这样即可：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">mint <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, mint x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!u) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (sz[ls[u]] &lt;= sz[rs[u]]) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz[ls[u]]; i++) res += x * h[i] * h[sz[u] - i - <span class="hljs-number">1</span>];<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		res += x * h[sz[u]];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= sz[rs[u]]; i++) res -= x * h[i] * h[sz[u] - i - <span class="hljs-number">1</span>];<br>	&#125;<br>	res += <span class="hljs-built_in">dfs2</span>(ls[u], x * h[sz[rs[u]]]);<br>	res += <span class="hljs-built_in">dfs2</span>(rs[u], x);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="Stirling-数"><a href="#Stirling-数" class="headerlink" title="Stirling 数"></a>Stirling 数</h1><h2 id="第二类-Stirling-数"><a href="#第二类-Stirling-数" class="headerlink" title="第二类 Stirling 数"></a>第二类 Stirling 数</h2><p>第二类 Stirling 数 $S(n,k)$ 表示将 $n$ 个不同元素分为 $k$ 个互不区分的非空<strong>子集</strong>的方案数。</p>
<p>第二类 Stirling 数有递推计算和通项计算两种计算方法。</p>
<h3 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h3><p>考虑到第 $n$ 个元素时，有两种方案：</p>
<ol>
<li>将第 $n$ 个元素单独放一个新子集，方案数为 $S(n-1,k-1)$；</li>
<li>将第 $n$ 个元素放一个已有子集，方案数为 $k \times S(n-1,k)$。</li>
</ol>
<p>由加法原理得：</p>
<p>$$<br>S(n,k)&#x3D;S(n-1,k-1)+k \times S(n-1,k)<br>$$</p>
<h3 id="通项公式-1"><a href="#通项公式-1" class="headerlink" title="通项公式"></a>通项公式</h3><p>$$<br>S(n,k)&#x3D;\sum_{i&#x3D;0}^{k} \dfrac{(-1)^{k-i} i^n}{i!(k-i)!}<br>$$</p>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>发现这个东西长的像二项式反演的式子，故设将 $n$ 个不同元素划分到 $i$ 个不同<strong>可空</strong>集合的方案数为 $g_i$，将 $n$ 个不同元素划分到 $i$ 个不同<strong>非空</strong>集合的方案数为 $g_i$。由乘法原理易得<br>$$<br>g_i&#x3D;i^n<br>$$<br>枚举选出多少个元素 $j$，则<br>$$<br>g_i&#x3D;\sum_{j&#x3D;0}^{i} C_i^j f_j<br>$$<br>这是二项式反演的标准形式。由二项式反演<br>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;\sum_{j&#x3D;0}^{i} (-1)^{i-j} C_i^j g_j\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{i} (-1)^{i-j} C_i^j j^n\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{i} \dfrac{i!(-1)^{i-j}j^n}{j!(i-j)!}<br>\end{aligned}<br>$$<br>得到了 $f_i$ 的通项公式。因为 $S(n,i)$ 中的子集互不区分，所以 $f_i$ 在 $S(n,i)$ 的基础上作了全排列，即 $f_i&#x3D;i! \times S(n,i)$，所以<br>$$<br>S(n,k)&#x3D;\dfrac{f_k}{k!}&#x3D;\sum_{i&#x3D;0}^{k} \dfrac{(-1)^{k-i} i^n}{i!(k-i)!}<br>$$</p>
<h2 id="第一类-Stirling-数"><a href="#第一类-Stirling-数" class="headerlink" title="第一类 Stirling 数"></a>第一类 Stirling 数</h2><p>第一类 Stirling 数 $s(n,k)$ 表示将 $n$ 个不同元素分为 $k$ 个互不区分的非空<strong>环形排列</strong>的方案数。</p>
<p>第一类 Stirling 数可通过递推计算。考虑到第 $n$ 个元素时，仍有两种方案：</p>
<ol>
<li>将第 $n$ 个元素单独放一个新环，方案数为 $s(n-1,k-1)$；</li>
<li>将第 $n$ 个元素放一个已有环，方案数为 $(n-1) \times s(n-1,k)$。</li>
</ol>
<p>由加法原理得：</p>
<p>$$<br>s(n,k)&#x3D;s(n-1,k-1)+(n-1) \times s(n-1,k)<br>$$</p>
<h2 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h2><h3 id="P1655-小朋友的球"><a href="#P1655-小朋友的球" class="headerlink" title="P1655 小朋友的球"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1655">P1655 小朋友的球</a></h3><p>这是第二类 Stirling 数的板子，但是需要高精度，代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n, m;<br>BigInteger s[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>			s[i][j] = s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + s[i - <span class="hljs-number">1</span>][j] * j;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>		cout &lt;&lt; s[n][m] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="B3801-NICA-1-乘只因"><a href="#B3801-NICA-1-乘只因" class="headerlink" title="B3801 [NICA #1] 乘只因"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/B3801">B3801 [NICA #1] 乘只因</a></h3><p>题里给的条件就是：<br>$$<br>\prod_{i&#x3D;1}^{k} a_i &#x3D; \operatorname{lcm}_{i&#x3D;1}^{k} a_i &#x3D;n<br>$$</p>
<p>因为 $\operatorname{lcm}<em>{i&#x3D;1}^{k}&#x3D;\dfrac{\prod</em>{i&#x3D;1}^{k} a_i}{\gcd_{i&#x3D;1}^{k} a_i}$，所以 $\gcd_{i&#x3D;1}^{k} a_i&#x3D;1$，而且又说了 $a$ 单调不降，就是说 $a$ 序列两两互质。对 $n$ 分解质因数得 $n&#x3D;p_1^{a_1} p_2^{a_2} \cdots$，发现若 $a_x \ne 0$，则这些 $p_x$ 只能被分配到同一个 $a_i$ 中。记有 $c$ 个不同质因子，然后你发现这是把 $c$ 个元素划成 $k$ 个子集的方案数，即第二类 Stirling 数。</p>
<p>实现细节上，注意特判掉 $c&lt;k$ 的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">decompose</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>		m++;<br>		<span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) m++;<br>	<span class="hljs-keyword">return</span> m;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-type">int</span> m = <span class="hljs-built_in">decompose</span>(n);<br>	cout &lt;&lt; (m &lt; k ? <span class="hljs-number">0</span> : s[m][k]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125; <span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>			s[i][j] = s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + s[i - <span class="hljs-number">1</span>][j] * j;<br>		&#125;<br>   &#125;<br>	<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (cin &gt;&gt; t; t--; ) _main();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4609-FJOI2016-建筑师"><a href="#P4609-FJOI2016-建筑师" class="headerlink" title="P4609 [FJOI2016] 建筑师"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4609">P4609 [FJOI2016] 建筑师</a></h3><p><del>单调栈经典模型。</del> 首先高度为 $n$ 的建筑肯定不会被挡，用它将建筑划分为两段，左边的看不到右边，右边的看不到左边。</p>
<p>推广一下，把 $n$ 的建筑分成 $a+b-1$ 个部分，把一个可以看到的和被它的分到一组去，一共是 $a+b-2$ 组。我们发现，每一组除了最高的建筑都可以任意排列，而且这还是一个环形排列，所以方案数是第一类 Stirling 数 $s(n-1,a+b-2)$。</p>
<p>然后再思考每一组的放置方法，这是一个组合数 $C_{a+b-2}^{a-1}$。由乘法原理合并答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> q, n, a, b;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">205</span>;<br>mint c[N][N], s[<span class="hljs-number">50005</span>][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">50005</span>; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) s[i][j] = s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + s[i - <span class="hljs-number">1</span>][j] * (i - <span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, c[i][i] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) c[i][j] = c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (cin &gt;&gt; q; q--; ) &#123;<br>		cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>		cout &lt;&lt; s[n - <span class="hljs-number">1</span>][a + b - <span class="hljs-number">2</span>] * c[a + b - <span class="hljs-number">2</span>][a - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Bell-数"><a href="#Bell-数" class="headerlink" title="Bell 数"></a>Bell 数</h1><p>Bell 数 $B_n$ 表示大小为 $n$ 的集合的划分方法数。例如，对于集合 ${1,2,3}$，有 $5$ 种划分方法：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1,2&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1,3&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">,</span><span class="hljs-template-variable">&#123;2,3&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure>

<p>所以 $B_3&#x3D;5$。</p>
<h2 id="递推公式-2"><a href="#递推公式-2" class="headerlink" title="递推公式"></a>递推公式</h2><p>设 $B_n$ 对应集合 ${a_1,a_2,a_3,\cdots,a_n}$，$B_{n+1}$ 对应集合 ${a_1,a_2,a_3,\cdots,a_n,a_{n+1}}$，只需考虑元素 $a_{n+1}$ 的贡献。</p>
<p>当它和 $k$ 个元素分到一个子集时，还剩下 $n-k$ 个元素，则多出的方案数有 $C_{n}^{n-k} B_{n-k}$，且 $k \in [0,n]$。因此：</p>
<p>$$<br>B_{n+1}&#x3D;\sum_{k&#x3D;0}^{n} C_n^k B_k<br>$$</p>
<p>仿照杨辉三角，可以构造一个贝尔三角形：</p>
<ul>
<li>$a_{0,0}&#x3D;1$；</li>
<li>$a_{n,0}&#x3D;a_{n-1,n-1}$；</li>
<li>$a_{n,m}&#x3D;a_{n,m-1}+a_{n-1,m-1}$。</li>
</ul>
<p>此时 $B_n&#x3D;a_{n,0}$。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> b[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<br>  b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>    b[i][<span class="hljs-number">0</span>] = b[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) b[i][j] = b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + b[i][j - <span class="hljs-number">1</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="与第二类-Stirling-数的关系"><a href="#与第二类-Stirling-数的关系" class="headerlink" title="与第二类 Stirling 数的关系"></a>与第二类 Stirling 数的关系</h2><p>枚举划分成 $k$ 个非空集合，则每种情况的方案数为第二类 Stirling 数 $S(n,k)$。于是：</p>
<p>$$<br>B_n&#x3D;\sum_{k&#x3D;0}^n S(n,k)<br>$$</p>
<p>这表明：Bell 数 $B_n$ 就是第 $n$ 行第二类 Stirling 数的和。</p>
<h2 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h2><h3 id="CF568B-Symmetric-and-Transitive"><a href="#CF568B-Symmetric-and-Transitive" class="headerlink" title="CF568B Symmetric and Transitive"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF568B">CF568B Symmetric and Transitive</a></h3><p>做一个图论建模。由对称性可得这是一个无向图，不妨设图中存在 $i$ 个孤立点，则选出孤立点的方案数是 $C_n^i$。然后剩下的分配就是上面讲的集合划分问题，为 $B_{n-i}$。由加法、乘法原理可得所求为</p>
<p>$$<br>\sum_{i&#x3D;1}^{n} C_n^i B_{n-i}<br>$$</p>
<p>然后组合数用杨辉三角，Bell 数用 Bell 三角预处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4005</span>;<br><span class="hljs-type">int</span> n;<br>mint b[N][N], c[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		b[i][<span class="hljs-number">0</span>] = b[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) b[i][j] = b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + b[i][j - <span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, c[i][i] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) c[i][j] = c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>	&#125;<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += c[n][i] * b[n - i][<span class="hljs-number">0</span>];<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="分拆数"><a href="#分拆数" class="headerlink" title="分拆数"></a>分拆数</h1><p>本来我不打算讲这个，但是 7.22 的模拟赛 T4 就是分拆数板子，并且我还没做出来。</p>
<p>定义分拆：将自然数 $n$ 写为递降正整数和的表示。如 $8&#x3D;5+2+1$。</p>
<p>分拆数 $p_n$：自然数 $n$ 的分拆方法数。</p>
<h2 id="k-部分拆数"><a href="#k-部分拆数" class="headerlink" title="$k$ 部分拆数"></a>$k$ 部分拆数</h2><p>将自然数 $n$ 分成恰好有 $k$ 个部分的分拆，称作 $k$ 部分拆数，记作 $p(n,k)$。如 $9&#x3D;6+2+1$ 是 $9$ 的一个 $3$ 部分拆。</p>
<p>考虑转移方程。</p>
<ol>
<li>单独分出一个 $1$，此时剩下数的和为 $n-1$，分 $k-1$ 组；</li>
<li>不选 $1$，不妨把每个数都减去 $1$ 转化为选 $1$ 的方案数，为 $n-k$ 分 $k$ 组。</li>
</ol>
<p>由加法原理得<br>$$<br>p(n,k)&#x3D;p(n-1,k-1)+p(n-k,k)<br>$$<br>边界为 $p(i,1)&#x3D;p(i,i)&#x3D;1$。模板题代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k;<br>mint dp[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dp[i][<span class="hljs-number">1</span>] = dp[i][i] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i; j++) &#123;<br>			dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[<span class="hljs-built_in">max</span>(i - j, <span class="hljs-number">0</span>)][j];<br>		&#125;<br>	&#125; cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>并且易得</p>
<p>$$<br>p_n&#x3D;\sum_{k&#x3D;1}^{n} p(n,k)<br>$$</p>
<h3 id="最大-k-分拆数"><a href="#最大-k-分拆数" class="headerlink" title="最大 $k$ 分拆数"></a>最大 $k$ 分拆数</h3><p>最大 $k$ 分拆数：自然数 $n$ 的最大分拆部分为 $k$ 的方法数。可以证明，最大 $k$ 分拆数等于 $p(n,k)$。</p>
<h2 id="互异分拆数"><a href="#互异分拆数" class="headerlink" title="互异分拆数"></a>互异分拆数</h2><p>互异分拆数 $pd_n$：自然数 $n$ 分拆成互不相同的数字的方法数。</p>
<p>同理地，定义 $pd(n,k)$ 表示 $n$ 分成 $k$ 个部分的互异分拆。考虑递推式，将所有数都减去 $k$，由于互异，数字中应当只有 $k$ 或 $k-1$ 个非零数，此时是对 $n-k$ 互异分拆的方案数，由加法原理得</p>
<p>$$<br>pd(n,k)&#x3D;pd(n-k,k)+pd(n-k,k-1)<br>$$</p>
<p>并且易得</p>
<p>$$<br>pd_n&#x3D;\sum_{k&#x3D;1}^{n} pd(n,k)<br>$$</p>
<h3 id="奇分拆数"><a href="#奇分拆数" class="headerlink" title="奇分拆数"></a>奇分拆数</h3><p>奇分拆数 $po_n$：自然数 $n$ 分拆成奇数的方法数。利用某些神奇方法，可以证明：</p>
<p>$$<br>po_n&#x3D;pd_n<br>$$</p>
<p>但是 $k$ 部奇分拆数不是 $k$ 部互异分拆数。</p>
<h2 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h2><p>有结论：</p>
<p>$$<br>p_n&#x3D;p_{n-1}+p_{n-2}-p_{n-5}-p_{n-7} +p_{n-12}+p_{n-15}-p_{n-22}- \cdots<br>$$</p>
<p>认为负数的分拆数为 $0$。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x5tfyila.png" srcset="/img/loading.gif" lazyload></p>
<p>像这张图一样，五边形数就是能够排列成正五边形的点数。这里的递推式系数 $1,2,5,7, 12,15,22\cdots$ 的通项公式为 $a_{2i}&#x3D;\dfrac{i(3i-2)}{2}$，而五边形数的通项为 $\dfrac{n(3n-1)}{2}$，所以这个东西叫做五边形数定理，需要用生成函数的方法证明。它的更一般规律是，系数递推式满足 $a_{2i}&#x3D;\dfrac{i(3i-2)}{2},a_{2i+1}&#x3D;\dfrac{i(3i+1)}{2}$，若 $4 \mid i$ 则符号为减号，否则为加号。利用五边形数定理可以 $O(n\sqrt{n})$ 计算分拆数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, a[N &lt;&lt; <span class="hljs-number">1</span>];<br>mint p[N];   <br><br><span class="hljs-type">void</span> _main() &#123;<br>	p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, p[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, p[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>		a[i &lt;&lt; <span class="hljs-number">1</span>] = i * (i * <span class="hljs-number">3</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>		a[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = i * (i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; N; i++) &#123;<br>		p[i] = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; a[j] &lt;= i; j++) &#123;<br>			<span class="hljs-keyword">if</span> (j &amp; <span class="hljs-number">2</span>) p[i] += p[i - a[j]];<br>			<span class="hljs-keyword">else</span> p[i] -= p[i - a[j]];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (cin &gt;&gt; n, n != <span class="hljs-number">-1</span>) cout &lt;&lt; p[n] &lt;&lt; endl;<br>&#125; <br></code></pre></td></tr></table></figure>

<h1 id="排列计数问题"><a href="#排列计数问题" class="headerlink" title="排列计数问题"></a>排列计数问题</h1><p>这一部分不属于组合数学内容，而是属于 DP 内容，但其思想方法与推导错排数、Stirling 数和 Bell 数有异曲同工之妙。</p>
<p>这类题目的 dp 状态一般设 $dp_{i, \cdots}$ 表示当前需要放入第 $i$ 个数的方案数，然后根据需要添加维度。在转移时，往往要从插入角度分类讨论 $i$ 带来的贡献，并根据乘法或加法原理合并答案。</p>
<h2 id="例题-11"><a href="#例题-11" class="headerlink" title="例题"></a>例题</h2><h3 id="P2401-不等数列"><a href="#P2401-不等数列" class="headerlink" title="P2401 不等数列"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2401">P2401 不等数列</a></h3><p>观察数据范围可以发现是一个 $O(nk)$ 的 dp，设 $dp_{i,j}$ 表示当前需要放入数字 $i$，有 $j$ 个小于号的方案数。分类讨论：</p>
<ol>
<li>若放在最左边，会多一个大于号，从 $dp_{i-1,j}$ 转移；</li>
<li>若放在最右边，会多一个小于号，从 $dp_{i-1,j-1}$ 转移；</li>
<li>若插入到小于号之前，因为数字 $i$ 是最大的，所以小于号变为大于号，而前面是一个小于号，因此是多了一个大于号，从 $j \times dp_{i-1,j}$ 转移；</li>
<li>若插入到大于号之前，同理可得转移为 $(i-j-1) \times dp_{i-1,j-1}$。</li>
</ol>
<p>由加法原理得：<br>$$<br>dp_{i,j}&#x3D;(j+1) \times  dp_{i-1,j} +(i-j) \times dp_{i-1,j-1}<br>$$<br>至此本题在 $O(nk)$ 内解决。边界为 $dp_{i,0}&#x3D;1$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> n, k;<br>mint dp[N][N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">min</span>(i, k); j++) &#123;<br>			dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] * (j + <span class="hljs-number">1</span>) + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * (i - j);<br>		&#125;<br>	&#125; cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P6323-COCI-2006-2007-4-ZBRKA"><a href="#P6323-COCI-2006-2007-4-ZBRKA" class="headerlink" title="P6323 [COCI 2006&#x2F;2007 #4] ZBRKA"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6323">P6323 [COCI 2006&#x2F;2007 #4] ZBRKA</a></h3><p>还是设 $dp_{i,j}$ 表示当前需要放入数字 $i$，有 $j$ 个逆序对的方案数。考虑插入在 $i-1$ 的全排列中插入 $i$ ，枚举增加了多少逆序对 $k$，则有<br>$$<br>dp_{i,j} &#x3D; \sum_{k&#x3D;0}^{\min(i-1,j)} dp_{i-1,j-k}<br>$$<br>直接做是 $O(nk^2)$ 的。注意到 $dp_{i,j}$ 为同一行 $dp_{i-1}$ 连续区间的和，用前缀和优化即可。考虑求 $j-k$ 的范围，发现 $j-k \in [\max(0, j-i+1), j]$。边界是 $dp_{i,0}&#x3D;1$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, k;<br>mint dp[N][<span class="hljs-number">10005</span>], pre[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">fill</span>(pre + <span class="hljs-number">1</span>, pre + k + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) dp[i][j] = pre[j + <span class="hljs-number">1</span>] - pre[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - i + <span class="hljs-number">1</span>)];<br>		pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) pre[j + <span class="hljs-number">1</span>] = pre[j] + dp[i][j];<br>	&#125;<br>	cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>三倍经验：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1521">P1521</a>、<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2513">P2513</a>。</p>
<h3 id="P7967-COCI-2021-2022-2-Magneti"><a href="#P7967-COCI-2021-2022-2-Magneti" class="headerlink" title="P7967 [COCI 2021&#x2F;2022 #2] Magneti"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7967">P7967 [COCI 2021&#x2F;2022 #2] Magneti</a></h3><p>好像这种问题叫做连续段 dp。</p>
<p>DP 题套路先对 $r_i$ 排序简化问题。仍然设 $dp_{i,\cdots}$ 表示当前需要放入第 $i$ 个磁铁的方案数。考虑加维，经过尝试发现空位要是单独一维，连通块也是单独一维。这里的连通块是一个磁铁的排列。因此，设 $dp_{i,j,k}$ 表示当前需要放入第 $i$ 个磁铁，分成 $j$ 个连通块，占用掉 $k$ 个空位的方案数。</p>
<p>考虑插入 $i$ 并分类讨论：</p>
<ol>
<li>若第 $i$ 个磁铁单独成为新的块，则从 $dp_{i-1,j-1,k-1}$ 转移；</li>
<li>若第 $i$ 个磁铁放在第 $j$ 个连通块端点，则从 $2j \times dp_{i-1,j,k-r_i}$ 转移。</li>
<li>若第 $i$ 个磁铁将两个连通块合并为一个，则从 $j(j+1) \times dp_{i-1,j+1, k-2r_i+1}$ 转移。</li>
</ol>
<p>于是状态转移方程为：<br>$$<br>dp_{i,j,k}&#x3D;dp_{i-1,j-1,k-1}+2j \times dp_{i-1,j,k-r_i}+j(j+1) \times dp_{i-1,j+1, k-2r_i+1}<br>$$<br>由此可以求出所有磁铁只形成一个连通块且长度为 $i$ 的方案数 $dp_{n,1,i}$，则根据插板法，答案为<br>$$<br>\sum_{i&#x3D;1}^{l} dp_{n,1,i} \times C_{l-i+n}^{n}<br>$$<br>时空 $O(n^2l)$，使用逆元法求组合数。边界为 $dp_{0,0,0}&#x3D;1$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br>mint fac[N], ifac[N], dp[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>][N];<br><br><span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> fac[n] * ifac[m] * ifac[n - m]; <br>&#125;<br><br><span class="hljs-type">int</span> n, l, r[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	fac[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">1</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i, ifac[i] = ~fac[i];<br>	cin &gt;&gt; n &gt;&gt; l;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; r[i];<br>	<span class="hljs-built_in">sort</span>(r + <span class="hljs-number">1</span>, r + n + <span class="hljs-number">1</span>);<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= l; k++) &#123;<br>				dp[i][j][k] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>];<br>				<span class="hljs-keyword">if</span> (k &gt;= r[i]) dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j][k - r[i]] * <span class="hljs-number">2</span> * j;<br>				<span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">2</span> * r[i] - <span class="hljs-number">1</span>) dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>][k - <span class="hljs-number">2</span> * r[i] + <span class="hljs-number">1</span>] * j * (j + <span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	mint res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; i++) res += dp[n][<span class="hljs-number">1</span>][i] * <span class="hljs-built_in">C</span>(l - i + n, n);<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>本来不打算讲的，但是发现 OI 里位运算的题也不少，所以开个新专题。</p>
<p>下文用符号 $\oplus$ 表示按位异或，$&amp;$ 表示按位与，$|$ 表示按位或。</p>
<h2 id="位运算常用性质"><a href="#位运算常用性质" class="headerlink" title="位运算常用性质"></a>位运算常用性质</h2><ol>
<li>由于异或是不进位加法，不退位减法，故 $x-y \le x \oplus y \le x + y$。</li>
<li>按位考虑 $x,y$ 的异同，有 $x+y&#x3D;(x&amp; y) +(x|y)$。</li>
<li>异或是不进位加法，而 $2(x &amp; y)$ 又能够表示加法进位，因此 $x+y&#x3D;(x \oplus y)+2(x &amp; y)$。</li>
<li>对于常数 $x,n$，满足 $x \oplus i \le n$ 的 $i$ 形成的区间有 $O(\log n)$ 个。</li>
</ol>
<h2 id="位运算进阶"><a href="#位运算进阶" class="headerlink" title="位运算进阶"></a>位运算进阶</h2><p>位运算基础就不讲了。让我们来考虑下列问题：</p>
<ol>
<li>定义 $\operatorname{lowbit}(x)$ 为 $x$ 最低位的 $1$ 及后面的 $0$ 组成的数。如何计算 $\operatorname{lowbit}(x)$ ？</li>
</ol>
<p>A: 将 $x$ 二进制位全部取反再加一。设原来 $x$ 的二进制表示形如 <code>(...)10...0000</code>，全部取反可得 <code>[...]01...1111</code>，加一即为 <code>[...]10...0000</code>，且 <code>[...]</code> 与 <code>(...)</code> 内容全部相反，两数或之，得 $10…0000$，即 $\operatorname{lowbit}(x)$。由补码性质可得 <code>~x + 1 = -x</code>，因而代码可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x &amp; -x;&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数在树状数组中有大用。还有一种方法是 $x-\operatorname{lowbit}(x)&#x3D;x&amp; (x-1)$。</p>
<ol start="2">
<li>定义 $\operatorname{popcount}(x)$ 为二进制下 $x$ 中 $1$ 的个数，如何计算 $\operatorname{popcount}(x)$？</li>
</ol>
<p>A: 考虑每次减去它的  $\operatorname{lowbit}$，复杂度 $O(\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; x; x -= <span class="hljs-built_in">lowbit</span>(x)) res++;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>GNU C++ 提供了函数 <code>__builtin_popcount(x)</code>，这个函数的速度远快于上面代码，可视为 $O(1)$。另有函数 <code>__builtin_popcountll(x)</code> 来计算 <code>long long</code> 类型的 $\operatorname{popcount}$。</p>
<ol start="3">
<li>使用一个 $n$ 位的二进制整数 $s$ 压位表示一个集合，如何降序枚举其子集？</li>
</ol>
<p>A: 先上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s; i; i = (i - <span class="hljs-number">1</span>) &amp; s);<br></code></pre></td></tr></table></figure>

<p>降序获得下一个子集，其实就是将它的最低位 $1$ 置为 $0$，减去 $1$ 即可，但是这会导致其最低位的 $1$ 后所有的 $0$ 变成了 $1$。通过按位与上 $s$，可以将那些多余的 $1$ 与 $0$ 而抵消。</p>
<p>可以发现其复杂度为 $O(2^{\operatorname{popcount}(n)})$。</p>
<ol start="4">
<li>考虑枚举 ${0,1,2, \cdots, n-1 }$ 的所有子集的所有子集，求复杂度？</li>
</ol>
<p>A: 根据问题 3，枚举方法显然：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j; j = (j - <span class="hljs-number">1</span>) &amp; i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>复杂度为 $O(3^n)$。我们根据组合数学知识来推导一下。考虑枚举每个子集中大小为 $i$ 的子集个数，则总数为<br>$$<br>\sum_{i&#x3D;0}^{n-1} C_n^i 2^i&#x3D;\sum_{i&#x3D;0}^{n-1} C_n^i 2^i 1^{n-i}&#x3D;(1+2)^n-1&#x3D;O(3^n)<br>$$<br>这里我们逆用了二项式定理。如果直接暴力复杂度为 $O(4^n)$，而这个低复杂度做法是状压 dp 的常用技巧。</p>
<h2 id="01-Trie"><a href="#01-Trie" class="headerlink" title="01-Trie"></a>01-Trie</h2><p>字符上的 Trie 属于字符串算法，而二进制上的 Trie 是解决异或问题的有力数据结构。</p>
<p>先介绍 Trie 树，其中文名为字典树，是一棵边带权的叶向树。借用 OI-Wiki 的图：</p>
<p><img src="https://oi-wiki.org/string/images/trie1.png" srcset="/img/loading.gif" lazyload alt="trie1"></p>
<p>可以发现，Trie 树通过把相同的字符串前缀压到一起，实现节省复杂度的目的。而如果字符集为 ${0,1}$，就叫做 01-Trie，下面我们来介绍 01-Trie 维护异或和时的操作。</p>
<h3 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入 &amp; 删除"></a>插入 &amp; 删除</h3><p>由于维护的是异或和，只需知道每一位上 $0&#x2F;1$ 的奇偶性。故节点需要维护以下三个数组：</p>
<ul>
<li><code>ch[0/1][x]</code>：维护节点 $x$ 的左 &#x2F; 右儿子；</li>
<li><code>w[x]</code>：维护 $x$ 子树权值的数目。当然这里直接维护奇偶性就行了。</li>
<li><code>xorv[x]</code>：维护 $x$ 子树的整体异或和。</li>
</ul>
<p>由此可以写出 01-Trie 的上传操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>    w[rt] = xorv[rt] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (ch[<span class="hljs-number">0</span>][rt]) &#123;<br>        w[rt] += w[ch[<span class="hljs-number">0</span>][rt]];<br>        xorv[rt] ^= xorv[ch[<span class="hljs-number">0</span>][rt]] &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ch[<span class="hljs-number">1</span>][rt]) &#123;<br>        w[rt] += w[ch[<span class="hljs-number">1</span>][rt]];<br>        xorv[rt] ^= (xorv[ch[<span class="hljs-number">1</span>][rt]] &lt;&lt; <span class="hljs-number">1</span>) | (w[ch[<span class="hljs-number">1</span>][rt]] &amp; <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入删除是平凡的，将数二进制拆分后在遍历路径中更新对应信息即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;<br>    cnt++;<br>    ch[<span class="hljs-number">1</span>][cnt] = ch[<span class="hljs-number">0</span>][cnt] = w[cnt] = xorv[cnt] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; rt, <span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">int</span> dep)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!rt) rt = <span class="hljs-built_in">newnode</span>();<br>    <span class="hljs-keyword">if</span> (dep &gt; H) <span class="hljs-keyword">return</span> w[rt]++, <span class="hljs-built_in">void</span>();<br>    <span class="hljs-built_in">insert</span>(ch[x &amp; <span class="hljs-number">1</span>][rt], x &gt;&gt; <span class="hljs-number">1</span>, dep + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">pushup</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">int</span> dep)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep &gt; H) <span class="hljs-keyword">return</span> w[rt]--, <span class="hljs-built_in">void</span>();<br>    <span class="hljs-built_in">remove</span>(ch[x &amp; <span class="hljs-number">1</span>][rt], x &gt;&gt; <span class="hljs-number">1</span>, dep + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">pushup</span>(rt);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="全局加一"><a href="#全局加一" class="headerlink" title="全局加一"></a>全局加一</h3><p>一个神奇操作。考虑二进制下如何加一：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10101 </span>+ <span class="hljs-number">1</span> = <span class="hljs-number">10110</span><br><span class="hljs-symbol">100000010111111 </span>+ <span class="hljs-number">1</span> = <span class="hljs-number">100000011000000</span><br></code></pre></td></tr></table></figure>

<p>只需要找到最低位的 $0$，将其变为 $1$，然后把后面的所有 $1$ 置 $0$ 即可。放到 Trie 上，直接交换左右儿子并沿交换后 $0$ 的权值边向下递归即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>    <span class="hljs-built_in">swap</span>(ch[<span class="hljs-number">0</span>][rt], ch[<span class="hljs-number">1</span>][rt]);<br>    <span class="hljs-keyword">if</span> (ch[<span class="hljs-number">0</span>][rt]) <span class="hljs-built_in">add1</span>(ch[<span class="hljs-number">0</span>][rt]);<br>    <span class="hljs-built_in">pushup</span>(rt);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>没错，这神奇玩意还能合并。如果你学过线段树合并或者 FHQ-Treap 的话，这个东西相当好理解。</p>
<p>先判掉 $x,y$ 是空树的情况。直接把 $b$ 的信息放到 $a$ 上，然后递归合并左右儿子即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!a || !b) <span class="hljs-keyword">return</span> a ? a : b;<br>    w[a] += w[b], xorv[a] ^= xorv[b];<br>    ch[<span class="hljs-number">0</span>][a] = <span class="hljs-built_in">merge</span>(ch[<span class="hljs-number">0</span>][a], ch[<span class="hljs-number">0</span>][b]), ch[<span class="hljs-number">1</span>][a] = <span class="hljs-built_in">merge</span>(ch[<span class="hljs-number">1</span>][a], ch[<span class="hljs-number">1</span>][b]);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此我们实现了一个支持插入 &#x2F; 删除，全局加一，合并，全局异或和的数据结构。自己造的 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U456135">板子题</a>。</p>
<h2 id="例题-12"><a href="#例题-12" class="headerlink" title="例题"></a>例题</h2><h3 id="P9451-ZSHOI-R1-新概念报数"><a href="#P9451-ZSHOI-R1-新概念报数" class="headerlink" title="P9451 [ZSHOI-R1] 新概念报数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9451">P9451 [ZSHOI-R1] 新概念报数</a></h3><p>分类讨论。设 $\operatorname{popcount}(a)&#x3D;p$，则：</p>
<ol>
<li>若 $p \ge 3$，报告无解；</li>
<li>若 $p \le 1$，直接输出 $a+1$，显然这样 $\operatorname{popcount(a+1)} \le 2$。</li>
<li>若 $p&#x3D;2$，找到 $a$ 二进制下最右侧的 $01$，然后改为 $10$ 即可。回顾一下问题 1，发现所求就是 $a+\operatorname{lowbit(a)}$。</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span> a;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; a;<br>	<span class="hljs-type">int</span> p = __builtin_popcountll(a);<br>	<span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-string">&quot;No,Commander\n&quot;</span>, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-keyword">if</span> (p &lt;= <span class="hljs-number">1</span>) cout &lt;&lt; a + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; a + (a &amp; -a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AT-abc365-e-ABC365E-Xor-Sigma-Problem"><a href="#AT-abc365-e-ABC365E-Xor-Sigma-Problem" class="headerlink" title="AT_abc365_e [ABC365E] Xor Sigma Problem"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc365_e">AT_abc365_e [ABC365E] Xor Sigma Problem</a></h3><p>写过<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/vkq0i7a0">题解</a>，复述一波：</p>
<p>显然 $a \oplus b \oplus b &#x3D;a$，所以考虑记录一个 $pre$ 数组记录前缀异或和。</p>
<p>则</p>
<p>$$<br>\begin{aligned}<br>\sum_{i&#x3D;1}^{i&lt;n} \sum_{j&#x3D;i+1}^{j\le n} \bigoplus_{k&#x3D;i}^{k \le j} a_k &amp;&#x3D;\sum_{i&#x3D;1}^{i\le n} \sum_{j&#x3D;i}^{j\le n} \bigoplus_{k&#x3D;i}^{k \le j} a_k - \sum_{i&#x3D;1}^{i\le n} a_i \<br>&amp;&#x3D; \sum_{i&#x3D;1}^{i\le n} \sum_{j&#x3D;i}^{j\le n} pre_{i} \oplus pre_{j} - \sum_{i&#x3D;1}^{i\le n} a_i<br>\end{aligned}<br>$$</p>
<p>其中 $\sum_{i&#x3D;1}^{i\le n} a_i$ 可以 $O(n)$ 计算，重点是计算前面这部分。</p>
<p>考虑把每个数按二进制拆分，逐位记录贡献，统计异或后二进制位为 $1$ 的贡献。</p>
<p>$\sum_{i&#x3D;1}^{i\le n} \sum_{j&#x3D;i}^{j\le n} pre_{i} \oplus pre_{j}$ 的意思是两两异或，所以可以用乘法原理，枚举二进制位 $d$，再设 $pre$ 中有 $s_0$ 个二进制第 $d$ 位为 $0$ 的，有 $s_1$ 个二进制第 $d$ 位为 $1$ 的，枚举前缀异或 $j$，第 $i$ 位贡献为 $2^i s_{1-pre_j}$。</p>
<p>时间复杂度 $O(n \log w)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N], pre[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> tot = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], tot += a[i], pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">27</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>		<span class="hljs-type">int</span> s[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-type">int</span> u = pre[j - <span class="hljs-number">1</span>] &gt;&gt; i &amp; <span class="hljs-number">1</span>, v = pre[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>			s[u]++, res += (<span class="hljs-number">1LL</span> &lt;&lt; i) * s[v ^ <span class="hljs-number">1</span>];  <br>		&#125;<br>	&#125;<br>	cout &lt;&lt; res - tot;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个题代表了一类位运算问题的套路，就是按位考虑贡献。</p>
<h3 id="UVA11825-Hackers’-Crackdown"><a href="#UVA11825-Hackers’-Crackdown" class="headerlink" title="UVA11825 Hackers’ Crackdown"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11825">UVA11825 Hackers’ Crackdown</a></h3><p>状压 dp 是位运算的经典应用。首先我们预处理出来每台电脑能瘫痪的二进制状态 $s_i$，再考虑所有状态的并集 $c$，设 $dp_{s}$ 表示状态 $s$ 能够瘫痪多少服务，考虑使用子集枚举，对全集 $s_1$ 枚举子集 $s_2$，则 $dp_{s_1 } \gets dp_{s_2-s_1}+1$，复杂度 $O(3^n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> n, m, a, s[N], c[<span class="hljs-number">1</span> &lt;&lt; N], dp[<span class="hljs-number">1</span> &lt;&lt; N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	<span class="hljs-type">int</span> kase = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (cin &gt;&gt; n, n) &#123;<br>		kase++;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>			cin &gt;&gt; m;<br>			s[i] = <span class="hljs-number">1</span> &lt;&lt; i;<br>			<span class="hljs-keyword">while</span> (m--) cin &gt;&gt; a, s[i] |= <span class="hljs-number">1</span> &lt;&lt; a;<br>		&#125;<br>		<span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(c)), <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>				<span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) c[i] |= s[j]; <br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j; j = (j - <span class="hljs-number">1</span>) &amp; i) &#123;<br>				<span class="hljs-keyword">if</span> (c[j] == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[i - j] + <span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; kase &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="P4310-绝世好题"><a href="#P4310-绝世好题" class="headerlink" title="P4310 绝世好题"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4310">P4310 绝世好题</a></h3><p>$O(n^2)$ 暴力 dp 显然。就是设 $dp_i $ 表示以 $a_i$ 结尾的子序列的最大长度，则枚举满足 $a_i &amp; a_j \ne 0$ 的 $j$ 有<br>$$<br>dp_i&#x3D;\max_{j&lt;i} {dp_j+1}<br>$$<br>考虑位运算经典套路拆位。观察 $a_i &amp; a_j \ne 0$ 这个条件，发现只要 $i,j$ 在二进制下有一个相同位的 $1$ 就能转移。那么我们枚举二进制位 $j$，设 $dp_j$ 表示 $j$ 位为 $1$ 时的最大长度。若 $a_i$ 在二进制下的第 $j$ 位不为 $0$，则有转移<br>$$<br>dp_j&#x3D;\max dp_{j’}+1<br>$$<br>这里 $j’$ 是另一个二进制位，由它转移而来即可。一个数 $a_i$ 可以被其二进制位的 $dp$ 转移，再转移到它二进制位的 $dp$ 值上。比较抽象，可以看代码理解。复杂度 $O(\log w)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N], dp[<span class="hljs-number">40</span>];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">31</span>; j++) &#123;<br>			<span class="hljs-keyword">if</span> (a[i] &gt;&gt; j &amp; <span class="hljs-number">1</span>) mx = <span class="hljs-built_in">max</span>(mx, dp[j]);<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">31</span>; j++) &#123;<br>			<span class="hljs-keyword">if</span> (a[i] &gt;&gt; j &amp; <span class="hljs-number">1</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], mx + <span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; *<span class="hljs-built_in">max_element</span>(dp, dp + <span class="hljs-number">32</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P10471-最大异或对-The-XOR-Largest-Pair"><a href="#P10471-最大异或对-The-XOR-Largest-Pair" class="headerlink" title="P10471 最大异或对 The XOR Largest Pair"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10471">P10471 最大异或对 The XOR Largest Pair</a></h3><p>感觉是 01-Trie 最经典的应用。先全部插入到 Trie 上，然后依次枚举每个数，找这个数能够形成的最大异或对。根据异或性质，我们贪心来取，每次尽量选不一样的数位遍历 01-Trie 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, ch[<span class="hljs-number">2</span>][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>		<span class="hljs-type">int</span> p = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (!ch[p][cur]) ch[p][cur] = ++cnt;<br>		cur = ch[p][cur];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>		<span class="hljs-type">int</span> p = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (!ch[p ^ <span class="hljs-number">1</span>][cur]) cur = ch[p][cur];<br>		<span class="hljs-keyword">else</span> cur = ch[p ^ <span class="hljs-number">1</span>][cur], res += (<span class="hljs-number">1</span> &lt;&lt; i);<br>	&#125; <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], <span class="hljs-built_in">insert</span>(a[i]);<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(a[i]));<br>	cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4551-最长异或路径"><a href="#P4551-最长异或路径" class="headerlink" title="P4551 最长异或路径"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></h3><p>好像没有头绪。记根节点到 $u$ 点的路径异或和为 $s_u$，推波式子：<br>$$<br>\begin{aligned}<br>e_u \oplus \cdots \oplus e_v &amp;&#x3D; e_u \oplus \cdots \oplus e_{lca(u,v)} \oplus e_v \oplus \cdots \oplus e_{lca(u,v)} \<br>&amp;&#x3D; e_1 \oplus \cdots \oplus e_{lca(u,v)} \oplus \cdots \oplus e_u  \oplus e_1 \oplus \cdots \oplus e_{lca(u,v)} \oplus \cdots \oplus e_v\<br>&amp;&#x3D;s_u \oplus s_v<br>\end{aligned}<br>$$<br>这里利用了异或性质 $a \oplus a&#x3D;0$，从根节点到 $lca(u,v)$ 这段路径异或两次就是没有异或。于是这题转化为上题。</p>
<h3 id="P6018-Ynoi2010-Fusion-tree"><a href="#P6018-Ynoi2010-Fusion-tree" class="headerlink" title="P6018 [Ynoi2010] Fusion tree"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6018">P6018 [Ynoi2010] Fusion tree</a></h3><p>我们发现操作 1 &amp; 3 都是相邻点的操作，不好在树上维护，因此我们统一维护所有点儿子的异或信息，单独处理父亲。然后用 01-Trie 来维护即可，对每个点打个标记维护增加量。单独处理的时候，先删除再插入即可，具体看代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to;<br>&#125; edge[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, head[u] = tot;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (ch[0][rt])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (ch[1][rt])</span><br><span class="hljs-type">int</span> cnt, w[N * <span class="hljs-number">21</span>], xorv[N * <span class="hljs-number">21</span>], ch[<span class="hljs-number">2</span>][N * <span class="hljs-number">21</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;<br>	cnt++;<br>	ch[<span class="hljs-number">1</span>][cnt] = ch[<span class="hljs-number">0</span>][cnt] = w[cnt] = xorv[cnt] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> cnt;<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>	w[rt] = xorv[rt] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (ls) w[rt] += w[ls], xorv[rt] ^= xorv[ls] &lt;&lt; <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (rs) w[rt] += w[rs], xorv[rt] ^= (xorv[rs] &lt;&lt; <span class="hljs-number">1</span>) | (w[rs] &amp; <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; rt, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dep = <span class="hljs-number">0</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!rt) rt = <span class="hljs-built_in">newnode</span>();<br>	<span class="hljs-keyword">if</span> (dep &gt; <span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> w[rt]++, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">insert</span>(ch[x &amp; <span class="hljs-number">1</span>][rt], x &gt;&gt; <span class="hljs-number">1</span>, dep + <span class="hljs-number">1</span>), <span class="hljs-built_in">pushup</span>(rt);<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dep = <span class="hljs-number">0</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (dep &gt; <span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> w[rt]--, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">remove</span>(ch[x &amp; <span class="hljs-number">1</span>][rt], x &gt;&gt; <span class="hljs-number">1</span>, dep + <span class="hljs-number">1</span>), <span class="hljs-built_in">pushup</span>(rt);<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!rt) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">swap</span>(ls, rs), <span class="hljs-built_in">add1</span>(ls), <span class="hljs-built_in">pushup</span>(rt);<br>&#125; <br><br><span class="hljs-type">int</span> n, q, u, v, a[N], opt, x, y;<br><span class="hljs-type">int</span> fa[N], rt[N], tag[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>		<span class="hljs-type">int</span> v = edge[j].to;<br>		<span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>		fa[v] = u, <span class="hljs-built_in">dfs</span>(v, u);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span> </span>&#123;   <span class="hljs-comment">// 单独处理节点x的权值</span><br>	<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) <span class="hljs-built_in">remove</span>(rt[fa[x]], a[x] + tag[fa[x]]);<br>	a[x] += c;<br>	<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(rt[fa[x]], a[x] + tag[fa[x]]);<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; q;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		<span class="hljs-built_in">add_edge</span>(u, v), <span class="hljs-built_in">add_edge</span>(v, u);<br>	&#125; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) <span class="hljs-built_in">insert</span>(rt[fa[i]], a[i]);<br>	<span class="hljs-keyword">while</span> (q--) &#123;<br>		cin &gt;&gt; opt &gt;&gt; x;<br>		<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>			tag[x]++, <span class="hljs-built_in">add1</span>(rt[x]);  <span class="hljs-comment">// 子树全局加1</span><br>			<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) <span class="hljs-built_in">change</span>(fa[x], <span class="hljs-number">1</span>);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;<br>			cin &gt;&gt; y, <span class="hljs-built_in">change</span>(x, -y);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) &#123;<br>			<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-keyword">if</span> (fa[x] != <span class="hljs-number">1</span>) cout &lt;&lt; (xorv[rt[x]] ^ (a[fa[x]] + tag[fa[fa[x]]])) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>				<span class="hljs-keyword">else</span> cout &lt;&lt; (xorv[rt[x]] ^ a[fa[x]]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				cout &lt;&lt; xorv[rt[x]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P6623-省选联考-2020-A-卷-树"><a href="#P6623-省选联考-2020-A-卷-树" class="headerlink" title="P6623 [省选联考 2020 A 卷] 树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6623">P6623 [省选联考 2020 A 卷] 树</a></h3><p>思考 $val(x)$ 的意义，可以发现一个暴力，就是将子树内的点权全部加 $1$ 后再异或起来贡献到父亲，是一个类似树形 dp 的思想。具体地，对于儿子 $v$ 的 $val_v &#x3D;a_1 \oplus a_2 \oplus \cdots \oplus a_k$，则贡献为 $(a_1+1) \oplus (a_2+1) \oplus \cdots \oplus (a_k+1)$，复杂度 $O(n^2)$。</p>
<p>考虑在在每个节点建立一棵 01-Trie，对儿子的 Trie 作合并并全局加一，然后把自己的点权放进去。</p>
<p>考虑复杂度。Trie 的合并操作当且仅当两棵 Trie 存在相同元素时产生 $O(\log n)$ 复杂度。设其出现 $x$ 次，总合并次数 $\sum x &#x3D; n$，因此复杂度为严格 $O(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> tot, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to;<br>&#125; edge[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, head[u] = tot;<br>&#125;<br><br><span class="hljs-type">int</span> n, a[N], f;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (ch[0][rt])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (ch[1][rt])</span><br><span class="hljs-type">int</span> cnt, w[N * <span class="hljs-number">20</span>], xorv[N * <span class="hljs-number">20</span>], ch[<span class="hljs-number">2</span>][N * <span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;<br>	cnt++;<br>	ch[<span class="hljs-number">1</span>][cnt] = ch[<span class="hljs-number">0</span>][cnt] = w[cnt] = xorv[cnt] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> cnt;<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>	w[rt] = xorv[rt] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (ls) w[rt] += w[ls], xorv[rt] ^= xorv[ls] &lt;&lt; <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (rs) w[rt] += w[rs], xorv[rt] ^= (xorv[rs] &lt;&lt; <span class="hljs-number">1</span>) | (w[rs] &amp; <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; rt, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dep = <span class="hljs-number">0</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!rt) rt = <span class="hljs-built_in">newnode</span>();<br>	<span class="hljs-keyword">if</span> (dep &gt; <span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> w[rt]++, <span class="hljs-built_in">void</span>();<br>	<span class="hljs-built_in">insert</span>(ch[x &amp; <span class="hljs-number">1</span>][rt], x &gt;&gt; <span class="hljs-number">1</span>, dep + <span class="hljs-number">1</span>), <span class="hljs-built_in">pushup</span>(rt);<br>&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!rt) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">swap</span>(ls, rs), <span class="hljs-built_in">add1</span>(ls), <span class="hljs-built_in">pushup</span>(rt);<br>&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!a || !b) <span class="hljs-keyword">return</span> a ? a : b;<br>	w[a] += w[b], xorv[a] ^= xorv[b];<br>	ch[<span class="hljs-number">0</span>][a] = <span class="hljs-built_in">merge</span>(ch[<span class="hljs-number">0</span>][a], ch[<span class="hljs-number">0</span>][b]), ch[<span class="hljs-number">1</span>][a] = <span class="hljs-built_in">merge</span>(ch[<span class="hljs-number">1</span>][a], ch[<span class="hljs-number">1</span>][b]);<br>	<span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-type">int</span> rt[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>		<span class="hljs-type">int</span> v = edge[j].to;<br>		<span class="hljs-built_in">dfs</span>(v), rt[u] = <span class="hljs-built_in">merge</span>(rt[u], rt[v]);<br>	&#125;<br>	<span class="hljs-built_in">add1</span>(rt[u]), <span class="hljs-built_in">insert</span>(rt[u], a[u]);<br>	ans += xorv[rt[u]];<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) cin &gt;&gt; f, <span class="hljs-built_in">add_edge</span>(f, i);<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); cout &lt;&lt; ans;<br>&#125; <br></code></pre></td></tr></table></figure>

<h1 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h1><p>分数规划一般与其他算法一起出现，比如：</p>
<ul>
<li>与 01 背包结合，称为最优比率背包；</li>
<li>与最小生成树结合，称为最优比率生成树；</li>
<li>与最短路结合，称为最优密度路径；</li>
<li>与 SPFA 判负环结合，称为最优比率环；</li>
<li>与网络流结合，称为最优密度子图。</li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>分数规划的基本模型是：有 $n$ 个物品，每种物品有两个权值 $a,b$，选出若干个最大化或最小化 $\dfrac{\sum a} {\sum b}$。</p>
<p>最常见的模型里每种物品只有选与不选两种可能，因而又被称作 01-分数规划。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>最值问题且满足单调性，二分启动。以最大值为例，我们二分答案 $mid$，则</p>
<p>由<br>$$<br>\dfrac{\sum a_i} {\sum b_i} &gt; mid<br>$$</p>
<p>可得</p>
<p>$$<br>\sum a_i - mid \times \sum b_i &gt; 0<br>$$</p>
<p>即</p>
<p>$$<br>\sum (a_i-mid \times b_i) &gt; 0<br>$$</p>
<p>由此得到二分的判定式。在分数规划的问题中，我们需要用其他方法求出 $\sum (a_i-mid \times b_i)$ 的最值并与 $0$ 比较。</p>
<h2 id="例题-13"><a href="#例题-13" class="headerlink" title="例题"></a>例题</h2><p>最大密度子图板子是 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA1389">UVA1389 Hard Life</a>，但是要用到笔者不太熟的网络流知识，这里就不讲了。</p>
<h3 id="U581184-【模板】01-分数规划"><a href="#U581184-【模板】01-分数规划" class="headerlink" title="U581184 【模板】01-分数规划"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U581184">U581184 【模板】01-分数规划</a></h3><p>自己造的板子。二分不变，可以贪心地去选，当且仅当 $a_i-mid \times b_i \ge 0$ 时我们才选这个物品。分数规划结合贪心。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, a[N], b[N];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-12</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += <span class="hljs-built_in">max</span>(a[i] - x * b[i], <span class="hljs-number">0.0</span>);<br>	<span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];<br>	<span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>, r = <span class="hljs-number">5e9</span>;<br>	<span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>		<span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>		<span class="hljs-keyword">else</span> r = mid;<br>	&#125;<br>	cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>) &lt;&lt; l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4377-USACO18OPEN-Talent-Show-G"><a href="#P4377-USACO18OPEN-Talent-Show-G" class="headerlink" title="P4377 [USACO18OPEN] Talent Show G"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4377">P4377 [USACO18OPEN] Talent Show G</a></h3><p>仔细审题可以发现，这题等价于上面的模型，加入一个 $\sum b_i \ge W$ 的限制。</p>
<p>$\sum b_i \ge W$ 可以想到背包的容量，于是以 $b_i$ 为重量，$a_i-mid \times b_i$ 为体积跑 01 背包即可。如果不会 01 背包推荐我的<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/6gosht8f">背包笔记</a>。复杂度 $O(nw \log V)$。分数规划结合 01 背包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, w, a[N], b[N];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= w; i++) dp[i] = <span class="hljs-number">-1e9</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = w; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>			dp[<span class="hljs-built_in">min</span>(w, j + b[i])] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-built_in">min</span>(w, j + b[i])], dp[j] + a[i] - x * b[i]);<br>		&#125;<br>	&#125; <span class="hljs-keyword">return</span> dp[w] &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; w;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i] &gt;&gt; a[i];<br>	<span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>, r = <span class="hljs-number">1e9</span>;<br>	<span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>		<span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>		<span class="hljs-keyword">else</span> r = mid;<br>	&#125; cout &lt;&lt; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) (<span class="hljs-number">1000</span> * l + eps);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="U589727-最优比率生成树"><a href="#U589727-最优比率生成树" class="headerlink" title="U589727 最优比率生成树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U589727">U589727 最优比率生成树</a></h3><p>还是二分，接下来我们以 $a_i-mid \times b_i$ 为边权跑最小生成树，判断边权和是否大于 $0$ 即可。注意本题是完全图，用 prim 跑最小生成树更优。分数规划结合最小生成树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-type">int</span> val[N][N], cost[N][N];<br><span class="hljs-type">double</span> w[N][N];<br><br><span class="hljs-type">int</span> n, m, u, v, x, y;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-4</span>;<br><br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">double</span> dis[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) w[i][j] = x * cost[i][j] - val[i][j];<br>	&#125;<br>	<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis)), <span class="hljs-built_in">fill</span>(dis + <span class="hljs-number">1</span>, dis + n + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>);<br>	dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>		<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; (x == <span class="hljs-number">0</span> || dis[j] &gt; dis[x])) x = j;<br>		&#125;<br>		vis[x] = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">if</span> (!vis[j]) dis[j] = <span class="hljs-built_in">max</span>(dis[j], w[x][j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) res += dis[i];<br>	<span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	m = n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	<span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>, r = <span class="hljs-number">5e6</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		cin &gt;&gt; u &gt;&gt; v &gt;&gt; x &gt;&gt; y; <br>		val[u][v] = val[v][u] = x;<br>		cost[u][v] = cost[v][u] = y;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>		<span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid - eps;<br>		<span class="hljs-keyword">else</span> l = mid + eps;<br>	&#125; cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P3199-HNOI2009-最小圈"><a href="#P3199-HNOI2009-最小圈" class="headerlink" title="P3199 [HNOI2009] 最小圈"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3199">P3199 [HNOI2009] 最小圈</a></h3><p>人话就是求一个环 $C$ 使得 $\dfrac{\sum_{e \in C} w_e}{|C|}$ 最小。还是二分，这题 $b_i&#x3D;1$，所以以 $a_i-mid$ 为边权。因为我们只需要判最小环是否小于 $0$，所以用 SPFA 判负环即可。分数规划结合 SPFA 判负环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to;<br>	<span class="hljs-type">double</span> dis;<br>&#125; edge[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">double</span> w)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, edge[tot].dis = w, head[u] = tot;<br>&#125;<br><span class="hljs-type">int</span> n, m, u, v; <span class="hljs-type">double</span> w;<br><br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">double</span> dis[N]; <span class="hljs-type">int</span> cnt[N];<br>bitset&lt;N&gt; vis;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dis[i] = <span class="hljs-number">1e9</span>;<br>	q.<span class="hljs-built_in">clear</span>(), <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt)), vis.<span class="hljs-built_in">reset</span>();<br>	q.<span class="hljs-built_in">emplace_back</span>(s), dis[s] = <span class="hljs-number">0</span>, vis[s] = <span class="hljs-number">1</span>, cnt[s] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop_front</span>(), vis[u] = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; dis[q.<span class="hljs-built_in">front</span>()] &gt; dis[q.<span class="hljs-built_in">back</span>()]) <span class="hljs-built_in">swap</span>(q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">back</span>());<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>			<span class="hljs-type">int</span> v = edge[j].to;<br>			<span class="hljs-type">double</span> w = edge[j].dis - x;<br>			<span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;<br>				dis[v] = dis[u] + w;<br>				<span class="hljs-keyword">if</span> (++cnt[v] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;<br>				vis[v] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">emplace_back</span>(v);<br>				<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; dis[q.<span class="hljs-built_in">front</span>()] &gt; dis[q.<span class="hljs-built_in">back</span>()]) <span class="hljs-built_in">swap</span>(q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">back</span>());<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, <span class="hljs-built_in">add_edge</span>(u, v, w);<br>	<span class="hljs-type">double</span> l = <span class="hljs-number">-1e7</span>, r = <span class="hljs-number">1e7</span>; <br>	<span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>		<span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>, mid)) r = mid;<br>		<span class="hljs-keyword">else</span> l = mid;<br>	&#125; cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; l;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这题即使用 SLF+swap 的 SPFA 也只有 90pts，使用玄学的 DFS-SPFA 可以水过：</p>
<blockquote>
<p>注意：DFS-SPFA 使用必须慎重，其最差复杂度为指数级。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> dis[N];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">double</span> x)</span> </span>&#123;<br>	vis[u] = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>		<span class="hljs-type">int</span> v = edge[j].to; <span class="hljs-type">double</span> w = edge[j].dis - x;<br>		<span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;<br>			dis[v] = dis[u] + w;<br>			<span class="hljs-keyword">if</span> (vis[v] || <span class="hljs-built_in">dfs</span>(v, x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>	&#125; <span class="hljs-keyword">return</span> vis[u] = <span class="hljs-literal">false</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-built_in">fill</span>(dis + <span class="hljs-number">1</span>, dis + n + <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>), <span class="hljs-built_in">fill</span>(vis + <span class="hljs-number">1</span>, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P1730-最小密度路径"><a href="#P1730-最小密度路径" class="headerlink" title="P1730 最小密度路径"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1730">P1730 最小密度路径</a></h3><p>还是分数规划的模型，二分起手，这题 $a_i&#x3D;w,b_i&#x3D;1$，然后以 $w-mid$ 为边权从 $u$ 到 $v$ 跑 SPFA 最短路即可。这题是最小值，所以就是判最短路小于 $0$。因为这题 $q$ 个询问只有 $O(n^2)$ 个本质不同，打个记忆化即可。分数规划结合最短路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-5</span>;<br><span class="hljs-type">int</span> n, m, u, v, w, q;<br><span class="hljs-type">double</span> ans[N][N];<br><br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to;<br>	<span class="hljs-type">double</span> dis;<br>&#125; edge[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">double</span> w)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, edge[tot].dis = w, head[u] = tot;<br>&#125;<br><span class="hljs-type">double</span> dis[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">double</span> x)</span> </span>&#123;<br>	<span class="hljs-built_in">fill</span>(dis + <span class="hljs-number">1</span>, dis + n + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>), <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">emplace</span>(s), dis[s] = <span class="hljs-number">0</span>, vis[s] = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>		vis[u] = <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>			<span class="hljs-type">int</span> v = edge[j].to; <span class="hljs-type">double</span> w = edge[j].dis - x;<br>			<span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;<br>				dis[v] = dis[u] + w;<br>				<span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;<br>				vis[v] = <span class="hljs-literal">true</span>, q.<span class="hljs-built_in">emplace</span>(v);<br>			&#125;<br>		&#125;<br>	&#125; <span class="hljs-keyword">return</span> dis[t] &lt; <span class="hljs-number">0</span>;<br>&#125;	<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>		<span class="hljs-built_in">add_edge</span>(u, v, w);<br>	&#125; cin &gt;&gt; q;<br>	<span class="hljs-keyword">while</span> (q--) &#123;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		<span class="hljs-keyword">if</span> (ans[u][v] != <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (ans[u][v] == <span class="hljs-number">-1</span>) cout &lt;&lt; <span class="hljs-string">&quot;OMG!\n&quot;</span>; <br>			<span class="hljs-keyword">else</span> cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; ans[u][v] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-type">double</span> l = <span class="hljs-number">0.0</span>, r = <span class="hljs-number">1e5</span>, res = <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>			<span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2.0</span>;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">spfa</span>(u, v, mid)) r = mid, res = r;<br>			<span class="hljs-keyword">else</span> l = mid;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) ans[u][v] = <span class="hljs-number">-1</span>, cout &lt;&lt; <span class="hljs-string">&quot;OMG!\n&quot;</span>;<br>		<span class="hljs-keyword">else</span> cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; (ans[u][v] = res) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>高斯消元是用来解线性方程组或异或方程组的一种算法。下面先以线性方程组</p>
<p>$$<br>\left{\begin{matrix}<br> 2x+y-z&#x3D;8  \<br> -3x-y+2z&#x3D;-11  \<br> -2x+y+2z&#x3D;-3<br>\end{matrix}\right.<br>$$</p>
<p>为例说明。</p>
<p>我们通过三种基本操作来消元（这些操作保证方程组的解不会改变）：</p>
<ol>
<li>交换方程位置：例如，把第一个方程和第二个方程互换。</li>
<li>乘以非零常数：例如，将某个方程两边同时乘以 2 或 -3（但不能乘以 0）。</li>
<li>添加一个方程的倍数：例如，把第一个方程的 2 倍加到第二个方程上。</li>
</ol>
<p>高斯消元有两个步骤，第一步为前向消元（即简化方程组），第二部为回代求解。</p>
<h3 id="前向消元"><a href="#前向消元" class="headerlink" title="前向消元"></a>前向消元</h3><p>这一步消元后，方程组变成“三角形”形式，即每个方程比前一个少一个变量。我们从上到下逐个变量处理。</p>
<ul>
<li><strong>第一步：在方程 2 和 3 中消去 $x$</strong><ul>
<li>把方程 1 作为最后留下 $x$ 的那个方程，因为 $x$ 的系数不为 $0$。</li>
<li>处理方程 2：计算一个倍数使得 $x$ 的系数为 $0$。倍数 $m&#x3D;\dfrac{-3}{2}&#x3D;-1.5$，也就是用方程 2 的 $x$ 系数去除以方程 1 的系数。则方程 2 化为 $(-3x-y+2z)-m(2x+y-z)&#x3D;0.5y+0.5z&#x3D;-11-8m&#x3D;1$。为方便讲解这里化为 $y+z&#x3D;2$。</li>
<li>处理方程 3：仿照上例，将方程 3 的 $x$ 系数化为 $0$。此时，$m&#x3D;\dfrac{-2}{2}&#x3D;-1$，方程 3 化为 $( -2x+y+2z)-m(2x+y-z)&#x3D;2y+z&#x3D;-3-8m&#x3D;5$。</li>
<li>现在方程组已经化为</li>
</ul>
</li>
</ul>
<p>$$<br>\left{\begin{matrix}<br> 2x+y-z&#x3D;8  \<br> y+z&#x3D;2  \<br> 2y+z&#x3D;5<br>\end{matrix}\right.<br>$$</p>
<ul>
<li><strong>第二步：在方程 3 中消去 $y$</strong><ul>
<li>此步骤忽略方程 1，因为其存在 $x$ 项。</li>
<li>把方程 2 作为最后留下 $y$ 的那个方程，因为 $y$ 的系数不为 $0$。</li>
<li>处理方程 3：仿照上例，将方程 3 的 $y$ 系数化为 $0$。此时，$m&#x3D;\dfrac{2}{1}&#x3D;2$，方程 3 化为 $(2y+z)-m(y+z)&#x3D;-z&#x3D;5-2m&#x3D;1$。</li>
<li>现在方程组已经化为</li>
</ul>
</li>
</ul>
<p>$$<br>\left{\begin{matrix}<br> 2x+y-z&#x3D;8  \<br> y+z&#x3D;2  \<br> -z&#x3D;1<br>\end{matrix}\right.<br>$$</p>
<p>至此，方程组已被化为“三角形”形式，最后一个方程可直接求得 $z&#x3D;-1$。</p>
<h3 id="回代求解"><a href="#回代求解" class="headerlink" title="回代求解"></a>回代求解</h3><p>从最后一个方程开始，逐个求解变量，并代入前一个方程。</p>
<p>比如这里求得 $z&#x3D;-1$，代入方程 2 得 $y&#x3D;3$，再代进方程 1 中解得 $x&#x3D;2$，所以方程组的解为</p>
<p>$$<br>\left{\begin{matrix}<br> x&#x3D;2  \<br> y&#x3D;3  \<br> z&#x3D;-1<br>\end{matrix}\right.<br>$$</p>
<p>还可以考虑无解 &#x2F; 无穷多解的情况。无解时，一条方程形如 $0x&#x3D;c$，其中 $c$ 是不为 $0$ 的常数。而无穷多解则是 $0x&#x3D;0$ 的形式。</p>
<p>代码上有很多细节，比如选择合适的顺序以减小浮点误差，交换方程等等。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp\">template &lt;int N&gt;<br>class GuassSolution &#123;<br>private:<br>	int n, m;<br>	double a[N][N];<br>public:<br>	explicit GuassSolution(int _n) : n(_n), m(0) &#123;&#125;<br>	template &lt;class T&gt; void add(const T&amp; it, double val) &#123;<br>		for (int i = 0; i &lt; n; i++) a[m][i] = it[i];<br>		a[m][n] = val, m++;<br>	&#125;<br>	<br>	template &lt;class T&gt; int solve(T it, double eps = 1e-9) &#123;  // 无解-1，唯一解0，无穷解1<br>		int ln = 0;<br>		for (int k = 0; k &lt; n; k++) &#123;  // 消去x_k<br>			int mx = ln;<br>			for (int i = ln + 1; i &lt; m; i++) &#123;<br>				if (abs(a[i][k]) &gt; abs(a[mx][k])) mx = i;<br>			&#125;  // 找最大系数，可以减小误差<br>			if (abs(a[mx][k]) &lt; eps) continue;<br>			for (int j = 0; j &lt;= n; j++) swap(a[ln][j], a[mx][j]);<br>			for (int i = 0; i &lt; m; i++) &#123;  // 在方程中消去x_k<br>				if (i == ln) continue;<br>				double x = a[i][k] / a[ln][k];  // 变系数<br>				for (int j = k; j &lt;= n; j++) a[i][j] -= a[ln][j] * x;  // 加减消元<br>			&#125;<br>			ln++;<br>		&#125;<br>		if (ln &lt; n) &#123;  // 意味着有一条方程的左边为 0<br>			for (; ln &lt; n; ln++) &#123;<br>				if (abs(a[ln][n]) &gt; eps) return -1;<br>			&#125;<br>			return 1;<br>		&#125;<br>		for (int i = 0; i &lt; n; i++) it[i] = a[i][n] / a[i][i];  // 回代求解<br>		return 0;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>显然可以看出复杂度为 $O(n^2m)$，其中 $n$ 为未知数的个数，$m$ 为方程的条数。</p>
<h2 id="异或方程组"><a href="#异或方程组" class="headerlink" title="异或方程组"></a>异或方程组</h2><p>上述过程可以给出线性方程组的数值解法，而若方程形如<br>$$<br>\left{\begin{matrix}<br>a_{1,1} x_1 \oplus a_{1,2} x_2 \oplus \cdots \oplus a_{1,n} x_n &#x3D; v_1 \<br>a_{2,1} x_1 \oplus a_{2,2} x_2 \oplus \cdots \oplus a_{2,n} x_n &#x3D; v_2 \<br>\cdots \<br>a_{m,1} x_1 \oplus a_{m,2} x_2 \oplus \cdots \oplus a_{m,n} x_n &#x3D; v_m<br>\end{matrix}\right.<br>$$<br>其中 $a_{i,i}, v_i \in {0,1}$，则仍然可以使用类似方法解决。具体地，因为异或有结合律、交换律，并且我们还不用乘除来改变系数，直接异或消元就行了。然而异或方程组会出现“自由元”，比如方程组<br>$$<br>\left{\begin{matrix}<br>x_1 \oplus x_2 &#x3D; 1 \<br>x_2 \oplus x_3 &#x3D; 1 \<br>x_1 \oplus x_3 &#x3D; 0<br>\end{matrix}\right.<br>$$<br>与线性方程组不同，即使 $n$ 元有 $n$ 个方程也会多解。上述异或方程组逻辑上为：$x_1&#x3D;x_3$ 且 $x_1 \ne x_2$。于是 $x_3$ 取 $0,1$ 都是可以的。对于这种自由元，我们只能全解完后 dfs 暴力求解。</p>
<p>可以用 bitset 优化，时间复杂度变为 $O(\dfrac{n^2m}{w})$。</p>
<h2 id="例题-14"><a href="#例题-14" class="headerlink" title="例题"></a>例题</h2><h3 id="P2455-SDOI2006-线性方程组"><a href="#P2455-SDOI2006-线性方程组" class="headerlink" title="P2455 [SDOI2006] 线性方程组"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2455">P2455 [SDOI2006] 线性方程组</a></h3><p>高斯消元板子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, a[N];<br><span class="hljs-type">double</span> x[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-function">GuassSolution&lt;N&gt; <span class="hljs-title">sol</span><span class="hljs-params">(n)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>		sol.<span class="hljs-built_in">add</span>(a, a[n]);<br>	&#125;<br>	<span class="hljs-type">int</span> opt = sol.<span class="hljs-built_in">solve</span>(x + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">-1</span>) cout &lt;&lt; <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>			cout &lt;&lt; <span class="hljs-string">&#x27;x&#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;=&#x27;</span>;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(x[i]) &gt; <span class="hljs-number">1e-5</span>) cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; x[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>			<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-comment">// 这里不这样处理的话会出现 -0.00 的输出</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P4035-JSOI2008-球形空间产生器"><a href="#P4035-JSOI2008-球形空间产生器" class="headerlink" title="P4035 [JSOI2008] 球形空间产生器"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4035">P4035 [JSOI2008] 球形空间产生器</a></h3><p>好像这题沦落为退火板子了（</p>
<p>根据题意列方程，设球心为 $(x_1,x_2,x_3,\cdots,x_n)$，则<br>$$<br>\forall 1 \le i \le n+1, \sum_{j&#x3D;1}^{n} (a_{i,j}-x_j)^2&#x3D;r^2<br>$$<br>定睛一看是二次方程。这里用到一个 trick，相邻两个方程作差，此时化为 $n$ 元一次方程组，满足<br>$$<br>\forall 1 \le i \le n, \sum_{j&#x3D;1}^{n} [{a_{i,j}}^2-{a_{i+1,j}}^2-2x_j(a_{i,j}-a_{i+1,j})]&#x3D;0<br>$$<br>化成标准形式<br>$$<br>\forall 1 \le i \le n, \sum_{j&#x3D;1}^{n} 2x_j(a_{i,j}-a_{i+1,j})&#x3D;\sum_{j&#x3D;1}^{n}({a_{i,j}}^2-{a_{i+1,j}}^2)<br>$$<br>于是就可以高斯消元解方程组了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> a[N][N], b[N], x[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) cin &gt;&gt; a[i][j];<br>	&#125;<br>	<span class="hljs-function">GuassSolution&lt;N&gt; <span class="hljs-title">sol</span><span class="hljs-params">(n)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-type">double</span> v = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			b[j - <span class="hljs-number">1</span>] = <span class="hljs-number">2.0</span> * (a[i][j] - a[i + <span class="hljs-number">1</span>][j]);<br>			v += a[i][j] * a[i][j] - a[i + <span class="hljs-number">1</span>][j] * a[i + <span class="hljs-number">1</span>][j];<br>		&#125; sol.<span class="hljs-built_in">add</span>(b, v);<br>	&#125; sol.<span class="hljs-built_in">solve</span>(x);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; x[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2011-计算电压"><a href="#P2011-计算电压" class="headerlink" title="P2011 计算电压"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2011">P2011 计算电压</a></h3><p>请物竞生来应该能秒掉罢。</p>
<p>考虑用物理知识列方程，由基尔霍夫定律可得流入电流等于流出电流，且根据电压本质是电势差可得<br>$$<br>\sum_{(j, i)} \dfrac{U_j-U_i}{R_{j,i}}&#x3D;\sum_{(i,k)} \dfrac{U_i-U_k}{R_{i,k}}<br>$$</p>
<p>用到了欧姆定律 $I&#x3D;\dfrac{U}{R}$。意义是 $i$ 节点的入边贡献的电流等于出边的总电流，取并集<br>$$<br>\sum_{(i,j)} \dfrac{U_j-U_i}{R_{i,j}}&#x3D;0<br>$$<br>这个式子最大的好处是化边权为点权且无需判断电流方向。</p>
<p>然后我们枚举点 $i$，若它直接连向电源，电压就是给出的值，否则枚举出边列方程，这样是一个 $n$ 元一次方程组，且主元系数均不为 $0$，故一定有解。可以发现复杂度为 $O(n^3+m)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, head[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> next, to; <span class="hljs-type">double</span> dis;<br>&#125; edge[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">double</span> w)</span> </span>&#123;<br>	edge[++tot].next = head[u], edge[tot].to = v, edge[tot].dis = w, head[u] = tot;<br>&#125;<br><br><span class="hljs-type">int</span> n, m, k, q, u, v, num;<br><span class="hljs-type">double</span> val, h[N], U0[N], U[N];<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;<br>	<span class="hljs-function">GuassSolution&lt;205&gt; <span class="hljs-title">sol</span><span class="hljs-params">(n)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) cin &gt;&gt; u &gt;&gt; U0[u];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;<br>		<span class="hljs-built_in">add_edge</span>(u, v, val), <span class="hljs-built_in">add_edge</span>(v, u, val);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++) &#123;<br>		<span class="hljs-built_in">fill</span>(h + <span class="hljs-number">1</span>, h + n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> (U0[u] &gt; <span class="hljs-number">0</span>) &#123;<br>			h[u] = <span class="hljs-number">1</span>, sol.<span class="hljs-built_in">add</span>(h + <span class="hljs-number">1</span>, U0[u]);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[u]; j != <span class="hljs-number">0</span>; j = edge[j].next) &#123;<br>				<span class="hljs-type">int</span> v = edge[j].to; <span class="hljs-type">double</span> w = edge[j].dis;<br>				h[v] += <span class="hljs-number">1.0</span> / w, h[u] -= <span class="hljs-number">1.0</span> / w;<br>			&#125; sol.<span class="hljs-built_in">add</span>(h + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>	sol.<span class="hljs-built_in">solve</span>(U + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">while</span> (q--) cin &gt;&gt; u &gt;&gt; v, cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; U[u] - U[v] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="P2447-SDOI2010-外星千足虫"><a href="#P2447-SDOI2010-外星千足虫" class="headerlink" title="P2447 [SDOI2010] 外星千足虫"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2447">P2447 [SDOI2010] 外星千足虫</a></h3><p>题意翻译：给出方程组<br>$$<br>\left{\begin{matrix}<br>a_{1,1} x_1 + a_{1,2} x_2 + \cdots + a_{1,n} x_n \equiv v_1 \pmod 2 \<br>a_{2,1} x_1 + a_{2,2} x_2 + \cdots + a_{2,n} x_n \equiv v_2 \pmod 2 \<br>\cdots \<br>a_{m,1} x_1 + a_{m,2} x_2 + \cdots + a_{m,n} x_n \equiv v_m \pmod 2<br>\end{matrix}\right.<br>$$<br>求方程组的解，并且求最少的方程条数使得方程组有唯一解。</p>
<p>思考一下模 $2$ 意义下的加法，发现这就是异或，于是第一问套用高斯消元即可。考虑第二问，显然至少要 $n$ 个方程才能解出 $n$ 元异或方程组，于是我们先解完 $n$ 个方程，若存在自由元就再加入新方程，直到有唯一解或者方程用完为止。使用 bitset 优化即可通过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>;<br><span class="hljs-type">int</span> n, m; <span class="hljs-type">char</span> c;<br>bitset&lt;N&gt; a[N];<br><span class="hljs-type">int</span> v[N], id[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guass</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>		<span class="hljs-type">int</span> mx = m + <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt;= m; i++) &#123;<br>			<span class="hljs-keyword">if</span> (a[i][k] &amp;&amp; id[mx] &gt; id[i]) mx = i;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (mx == m + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		cnt = <span class="hljs-built_in">max</span>(cnt, id[mx]);<br>		<span class="hljs-built_in">swap</span>(a[k], a[mx]), <span class="hljs-built_in">swap</span>(v[k], v[mx]), <span class="hljs-built_in">swap</span>(id[k], id[mx]);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>			<span class="hljs-keyword">if</span> (i != k &amp;&amp; a[i][k]) a[i] ^= a[k], v[i] ^= v[k];<br>		&#125;<br>	&#125; <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">void</span> _main() &#123;<br>	cin &gt;&gt; n &gt;&gt; m; <br>	<span class="hljs-built_in">iota</span>(id + <span class="hljs-number">1</span>, id + m + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) cin &gt;&gt; c, a[i][j] = c ^ <span class="hljs-number">48</span>;<br>		cin &gt;&gt; c, v[i] = c ^ <span class="hljs-number">48</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> h = <span class="hljs-built_in">guass</span>();<br>	<span class="hljs-keyword">if</span> (h == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> cout &lt;&lt; <span class="hljs-string">&quot;Cannot Determine&quot;</span>, <span class="hljs-built_in">void</span>();<br>	cout &lt;&lt; h &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cout &lt;&lt; (v[i] ? <span class="hljs-string">&quot;?y7M#\n&quot;</span> : <span class="hljs-string">&quot;Earth\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2025/08/05/OI 中的数学基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>stripe-python</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
